// ==========================================================
// deep scan window scriptÔºàunified regex versionÔºâ
// all regex unifiedÈÄöthrough SettingsManager Ëé∑ÂèñÔºåÊó†‰ªª‰ΩïÁ°¨ÁºñÁ†Å
// ==========================================================

//console.log('üöÄ [DEBUG] deep scan window scriptÔºàunified regex versionÔºâstart load ...');

// -------------------- ÂÖ®Â±Ä variable --------------------
let scanConfig         = null;
let scanResults        = {};
let isScanRunning      = false;
let isPaused           = false;
let currentDepth       = 0;
let scannedUrls        = new Set();
let pendingUrls        = new Set();
let urlContentCache    = new Map();
let activeRequests     = 0;
let maxConcurrency     = 4; // default valueÔºå‰ºöfrom extension settings inread
let requestTimeout     = 3000; // default valueÔºå‰ºöfrom extension settings inread

// log Áõ∏ÂÖ≥ variable - optimization version
let logEntries         = [];
let maxLogEntries      = 100; // reduceÂà∞100Êù°ÔºåÈÅøÂÖçÂÜÖÂ≠òÂç†Áî®
let logBuffer          = []; // log ÁºìÂÜ≤Âå∫
let logFlushTimer      = null;
const LOG_FLUSH_INTERVAL = 500; // 500ms batch refresh log

// filterÂô®ÂÆû‰æã
let apiFilter          = null;
let domainPhoneFilter  = null;
let filtersLoaded      = false;
let patternExtractor   = null;

// performance optimization Áõ∏ÂÖ≥ variable
let updateQueue        = [];
let isUpdating         = false;
let lastUpdateTime     = 0;
const UPDATE_THROTTLE  = 300; // üöÄ Â¢ûÂä†Âà∞300msËäÇÊµÅÔºåreduce update È¢ëÁéá
let pendingResults     = {};
let batchSize          = 15; // üöÄ Â¢ûÂä† batch process size
let updateTimer        = null;
let displayUpdateCount = 0;

// üöÄ ÂÜÖÂ≠ò manage Áõ∏ÂÖ≥ variable
let memoryCleanupTimer = null;
const MEMORY_CLEANUP_INTERVAL = 30000; // 30 seconds cleanup ‰∏ÄÊ¨°ÂÜÖÂ≠ò

// -------------------- performance optimization tool function --------------------

// üöÄ ÂÜÖÂ≠ò cleanup function
function performMemoryCleanup() {
    //console.log('üßπ execute ÂÜÖÂ≠ò cleanup ...');
    
    // cleanup URL content cacheÔºåÂè™keepÊúÄËøë 50 items
    if (urlContentCache.size > 50) {
        const entries = Array.from(urlContentCache.entries());
        const toKeep = entries.slice(-50);
        urlContentCache.clear();
        toKeep.forEach(([key, value]) => urlContentCache.set(key, value));
        //console.log(`üßπ cleanup URL cacheÔºåkeep ${toKeep.length} ‰∏™Êù°ÁõÆ`);
    }
    
    // cleanup log ÁºìÂÜ≤Âå∫
    if (logBuffer && logBuffer.length > 0) {
        flushLogBuffer();
    }
    
    // force ÂûÉÂúæÂõûÊî∂ÔºàÂ¶ÇÊûúÂèØÁî®Ôºâ
    if (window.gc) {
        window.gc();
    }
}

// ÂêØÂä®ÂÜÖÂ≠ò cleanup ÂÆöÊó∂Âô®
function startMemoryCleanup() {
    if (memoryCleanupTimer) {
        clearInterval(memoryCleanupTimer);
    }
    memoryCleanupTimer = setInterval(performMemoryCleanup, MEMORY_CLEANUP_INTERVAL);
}

// ÂÅúÊ≠¢ÂÜÖÂ≠ò cleanup ÂÆöÊó∂Âô®
function stopMemoryCleanup() {
    if (memoryCleanupTimer) {
        clearInterval(memoryCleanupTimer);
        memoryCleanupTimer = null;
    }
}

function convertRelativeToAbsolute(relativePath) {
    try {
        const base = scanConfig?.baseUrl || window.location.origin;
        return new URL(relativePath, base).href;
    } catch {
        return relativePath;
    }
}

function loadScript(src) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        const url = (typeof chrome !== 'undefined' && chrome.runtime?.getURL) ? chrome.runtime.getURL(src) : src;
        script.src = url;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

// -------------------- unifiedfilterÂô® load --------------------
async function loadFilters() {
    //console.log('üîç [DEBUG] start load unifiedfilterÂô®...');

    try {
        // load SettingsManagerÔºàÂøÖÈ°ªÔºâ
        if (typeof window.SettingsManager === 'undefined') {
            await loadScript('src/utils/SettingsManager.js');
        }

        // load PatternExtractorÔºàÂøÖÈ°ªÔºâ
        if (typeof window.PatternExtractor === 'undefined') {
            await loadScript('src/scanner/PatternExtractor.js');
        }

        // wait script Ëß£Êûê
        await new Promise(r => setTimeout(r, 100));

        // ÂÆû‰æãÂåñ
        if (typeof window.PatternExtractor === 'undefined') {
            throw new Error('PatternExtractor not load success');
        }
        patternExtractor = new window.PatternExtractor();

        // force load custom regex
        if (typeof patternExtractor.ensureCustomPatternsLoaded === 'function') {
            patternExtractor.ensureCustomPatternsLoaded();
        }

        // listen settings È°µ regex update
        window.addEventListener('regexConfigUpdated', (e) => {
            //console.log('üîÑ [DEBUG] received regex configuration update event');
            if (patternExtractor?.updatePatterns) {
                patternExtractor.updatePatterns(e.detail);
            } else if (patternExtractor?.loadCustomPatterns) {
                patternExtractor.loadCustomPatterns(e.detail);
            }
        });

        filtersLoaded = true;
        //console.log('‚úÖ [DEBUG] unifiedfilterÂô® load ÂÆåÊØï');
    } catch (err) {
        console.error('‚ùå [DEBUG] filterÂô® load failed:', err);
        filtersLoaded = false;
    }
}

// -------------------- unified content extract --------------------
async function extractFromContent(content, sourceUrl = 'unknown') {
    //console.log('üîç [DEBUG] start unified content extract ...');

    if (!patternExtractor || typeof patternExtractor.extractPatterns !== 'function') {
        throw new Error('PatternExtractor.extractPatterns do notÂèØÁî®');
    }

    // Á°Æ‰øù configuration already load
    if (typeof patternExtractor.ensureCustomPatternsLoaded === 'function') {
        await patternExtractor.ensureCustomPatternsLoaded();
    }

    // useunifiedÂÖ•Âè£ extract
    const results = await patternExtractor.extractPatterns(content, sourceUrl);

    // üî• fixÔºöuse IndexedDB data ËøõË°åÊô∫ËÉΩÁõ∏ÂØπ path Ëß£Êûê
    await enhanceRelativePathsWithIndexedDB(results, sourceUrl);

    return results;
}

// -------------------- Êô∫ËÉΩÁõ∏ÂØπ path Ëß£Êûê --------------------
async function enhanceRelativePathsWithIndexedDB(results, currentSourceUrl) {
    console.log('üîç [DEBUG] start Êô∫ËÉΩÁõ∏ÂØπ path Ëß£ÊûêÔºåcurrent Ê∫êURL:', currentSourceUrl);
    
    if (!results.relativeApis || results.relativeApis.length === 0) {
        console.log('‚ö†Ô∏è Ê≤°ÊúâÁõ∏ÂØπ path APIrequireËß£Êûê');
        return;
    }
    
    try {
        // üî• fixÔºö‰∏•Ê†ºÊåâÁÖßIndexedDB data Ëé∑Âèñ extract Êù•Ê∫ê path
        const baseUrl = scanConfig?.baseUrl || window.location.origin;
        console.log('üîç [DEBUG] basicURL:', baseUrl);
        
        // Ëé∑Âèñall scan result dataÔºåpackage Êã¨ deep scan result
        let allScanData = [];
        
        // method 1ÔºöÂ∞ùËØïËé∑Âèñ current domain   scan result
        try {
            const currentScanData = await window.IndexedDBManager.loadScanResults(baseUrl);
            if (currentScanData && currentScanData.results) {
                allScanData.push(currentScanData);
                console.log('‚úÖ [DEBUG] Ëé∑ÂèñÂà∞ current domain scan result');
            }
        } catch (e) {
            console.warn('‚ö†Ô∏è Ëé∑Âèñ current domain scan result failed:', e);
        }
        
        // method 2ÔºöËé∑Âèñall scan result ‰ΩútoÂ§áÈÄâ
        try {
            const allResults = await window.IndexedDBManager.getAllScanResults();
            if (allResults && Array.isArray(allResults)) {
                allScanData = allScanData.concat(allResults);
                console.log('‚úÖ [DEBUG] Ëé∑ÂèñÂà∞all scan resultÔºåÂÖ±', allResults.length, '‰∏™');
            }
        } catch (e) {
            console.warn('‚ö†Ô∏è Ëé∑Âèñall scan result failed:', e);
        }
        
        if (allScanData.length === 0) {
            console.log('‚ö†Ô∏è Êú™ÊâæÂà∞‰ªª‰Ωï IndexedDB dataÔºåuse‰º†ÁªüÊãºÊé•ÊñπÂºè');
            return;
        }
        
        // üî• fixÔºö‰∏•Ê†ºÊåâÁÖßIndexedDBinÊØè‰∏™ data È°π sourceUrlËøõË°å path Ëß£Êûê
        const sourceUrlToBasePath = new Map();
        const itemToSourceUrlMap = new Map(); // Êñ∞Â¢ûÔºöÂª∫Á´ã data È°πÂà∞sourceUrl  map
        
        console.log('üîç [DEBUG] start analysis IndexedDB dataÔºåÂÖ±', allScanData.length, '‰∏™ data Ê∫ê');
        
        // ÈÅçÂéÜall scan dataÔºåÂª∫Á´ãcomplete  map ÂÖ≥system
        allScanData.forEach((scanData, dataIndex) => {
            if (!scanData.results) return;
            
            console.log(`üîç [DEBUG] analysis data Ê∫ê ${dataIndex + 1}:`, {
                url: scanData.url,
                sourceUrl: scanData.sourceUrl,
                domain: scanData.domain,
                pageTitle: scanData.pageTitle
            });
            
            // ÈÅçÂéÜall type   data
            Object.entries(scanData.results).forEach(([category, items]) => {
                if (!Array.isArray(items)) return;
                
                items.forEach(item => {
                    if (typeof item === 'object' && item !== null && item.sourceUrl) {
                        // üî• ÂÖ≥ key fixÔºöuse data È°πËá™Â∑± sourceUrl
                        const itemSourceUrl = item.sourceUrl;
                        const itemValue = item.value || item.text || item.content;
                        
                        if (itemValue && itemSourceUrl) {
                            try {
                                const sourceUrlObj = new URL(itemSourceUrl);
                                // extract basic pathÔºàÂéªÊéâ file ÂêçÔºâ
                                const basePath = sourceUrlObj.pathname.substring(0, sourceUrlObj.pathname.lastIndexOf('/') + 1);
                                const fullBasePath = `${sourceUrlObj.protocol}//${sourceUrlObj.host}${basePath}`;
                                
                                sourceUrlToBasePath.set(itemSourceUrl, fullBasePath);
                                itemToSourceUrlMap.set(itemValue, itemSourceUrl);
                                
                                console.log(`üìã [DEBUG] map Âª∫Á´ã: "${itemValue}" -> "${itemSourceUrl}" -> "${fullBasePath}"`);
                            } catch (e) {
                                console.warn('‚ö†Ô∏è invalid  sourceUrl:', itemSourceUrl, e);
                            }
                        }
                    } else if (typeof item === 'string') {
                        // ÂØπ‰∫é string format   dataÔºåuse scan result  sourceUrl
                        const fallbackSourceUrl = scanData.sourceUrl || scanData.url;
                        if (fallbackSourceUrl) {
                            try {
                                const sourceUrlObj = new URL(fallbackSourceUrl);
                                const basePath = sourceUrlObj.pathname.substring(0, sourceUrlObj.pathname.lastIndexOf('/') + 1);
                                const fullBasePath = `${sourceUrlObj.protocol}//${sourceUrlObj.host}${basePath}`;
                                
                                sourceUrlToBasePath.set(fallbackSourceUrl, fullBasePath);
                                itemToSourceUrlMap.set(item, fallbackSourceUrl);
                                
                                console.log(`üìã [DEBUG] Â§áÈÄâ map: "${item}" -> "${fallbackSourceUrl}" -> "${fullBasePath}"`);
                            } catch (e) {
                                console.warn('‚ö†Ô∏è invalid  Â§áÈÄâsourceUrl:', fallbackSourceUrl, e);
                            }
                        }
                    }
                });
            });
        });
        
        console.log('üìä [DEBUG] map Âª∫Á´ã complete:', {
            sourceUrlToBasePath: sourceUrlToBasePath.size,
            itemToSourceUrlMap: itemToSourceUrlMap.size
        });
        
        // üî• fixÔºö‰∏•Ê†ºÊåâÁÖßÊØè‰∏™Áõ∏ÂØπ path API Êù•Ê∫êËøõË°åËß£Êûê
        const enhancedRelativeApis = [];
        
        for (const apiItem of results.relativeApis) {
            const apiValue = typeof apiItem === 'object' ? apiItem.value : apiItem;
            let apiSourceUrl = typeof apiItem === 'object' ? apiItem.sourceUrl : currentSourceUrl;
            
            console.log(`üîç [DEBUG] process Áõ∏ÂØπ path API: "${apiValue}", Ê∫êURL: "${apiSourceUrl}"`);
            
            let resolvedUrl = null;
            let usedSourceUrl = null;
            
            // üî• method 1Ôºö‰∏•Ê†ºÊåâÁÖß data È°π sourceUrlËøõË°åËß£Êûê
            if (itemToSourceUrlMap.has(apiValue)) {
                const exactSourceUrl = itemToSourceUrlMap.get(apiValue);
                if (sourceUrlToBasePath.has(exactSourceUrl)) {
                    const basePath = sourceUrlToBasePath.get(exactSourceUrl);
                    resolvedUrl = resolveRelativePath(apiValue, basePath);
                    usedSourceUrl = exactSourceUrl;
                    console.log('‚úÖ [Á≤æÁ°Æ match] ÊâæÂà∞ data È°π Á°ÆÂàáÊù•Ê∫ê:', apiValue, '->', resolvedUrl, '(Ê∫ê:', exactSourceUrl, ')');
                }
            }
            
            // üî• method 2ÔºöÂ¶ÇÊûúÁ≤æÁ°Æ match failedÔºåuseAPIÈ°πÁõÆËá™Â∏¶ sourceUrl
            if (!resolvedUrl && apiSourceUrl && sourceUrlToBasePath.has(apiSourceUrl)) {
                const basePath = sourceUrlToBasePath.get(apiSourceUrl);
                resolvedUrl = resolveRelativePath(apiValue, basePath);
                usedSourceUrl = apiSourceUrl;
                console.log('‚úÖ [directly match] useAPIÈ°πÁõÆ sourceUrl:', apiValue, '->', resolvedUrl, '(Ê∫ê:', apiSourceUrl, ')');
            }
            
            // üî• method 3ÔºöÂ¶ÇÊûúËøòÊòØ failedÔºåÂ∞ùËØïÊü•ÊâæÁõ∏‰ºº Ê∫êURLÔºàdomain matchÔºâ
            if (!resolvedUrl && sourceUrlToBasePath.size > 0) {
                const targetDomain = baseUrl ? new URL(baseUrl).hostname : null;
                
                for (const [sourceUrl, basePath] of sourceUrlToBasePath.entries()) {
                    try {
                        const sourceDomain = new URL(sourceUrl).hostname;
                        if (targetDomain && sourceDomain === targetDomain) {
                            const testUrl = resolveRelativePath(apiValue, basePath);
                            if (testUrl) {
                                resolvedUrl = testUrl;
                                usedSourceUrl = sourceUrl;
                                console.log('‚úÖ [domain match] ÊâæÂà∞Âêå domain  Ê∫êURL:', apiValue, '->', resolvedUrl, '(Ê∫ê:', sourceUrl, ')');
                                break;
                            }
                        }
                    } catch (e) {
                        // ÂøΩÁï• invalid URL
                    }
                }
            }
            
            // üî• method 4ÔºöÊúÄÂêé Â§áÈÄâÊñπÊ°àÔºåusebasicURLÊãºÊé•
            if (!resolvedUrl) {
                try {
                    if (apiValue.startsWith('./')) {
                        resolvedUrl = baseUrl + apiValue.substring(1); // ÂéªÊéâ.Ôºåkeep/
                    } else if (apiValue.startsWith('../')) {
                        // simple process ‰∏äÁ∫ßÁõÆÂΩï
                        const upLevels = (apiValue.match(/\.\.\//g) || []).length;
                        const remainingPath = apiValue.replace(/\.\.\//g, '');
                        const baseUrlObj = new URL(baseUrl);
                        const pathParts = baseUrlObj.pathname.split('/').filter(p => p);
                        
                        // Âêë‰∏äÁßªÂä®ÊåáÂÆöÂ±ÇÁ∫ß
                        for (let i = 0; i < upLevels && pathParts.length > 0; i++) {
                            pathParts.pop();
                        }
                        
                        resolvedUrl = `${baseUrlObj.protocol}//${baseUrlObj.host}/${pathParts.join('/')}${pathParts.length > 0 ? '/' : ''}${remainingPath}`;
                    } else if (!apiValue.startsWith('/') && !apiValue.startsWith('http')) {
                        resolvedUrl = baseUrl + '/' + apiValue;
                    } else {
                        resolvedUrl = apiValue;
                    }
                    
                    // cleanup Â§ö‰Ωô ÊñúÊù†
                    resolvedUrl = resolvedUrl.replace(/\/+/g, '/').replace(':/', '://');
                    usedSourceUrl = baseUrl;
                    
                    console.log('üîÑ [Â§áÈÄâËß£Êûê] usebasicURLÊãºÊé•:', apiValue, '->', resolvedUrl);
                } catch (e) {
                    resolvedUrl = apiValue; // ‰øùÊåÅÂéü value
                    usedSourceUrl = currentSourceUrl;
                    console.warn('‚ö†Ô∏è [Ëß£Êûê failed] ‰øùÊåÅÂéü value:', apiValue, e.message);
                }
            }
            
            // ‰øùÊåÅÂéüÂßã formatÔºåadd Ëß£ÊûêÂêé  URL andÂÆûÈôÖuse Ê∫êURL
            if (typeof apiItem === 'object') {
                enhancedRelativeApis.push({
                    ...apiItem,
                    resolvedUrl: resolvedUrl,
                    actualSourceUrl: usedSourceUrl || apiItem.sourceUrl // ËÆ∞ÂΩïÂÆûÈôÖuse Ê∫êURL
                });
            } else {
                enhancedRelativeApis.push({
                    value: apiItem,
                    sourceUrl: usedSourceUrl || currentSourceUrl,
                    resolvedUrl: resolvedUrl,
                    actualSourceUrl: usedSourceUrl
                });
            }
        }
        
        // update result
        results.relativeApis = enhancedRelativeApis;
        
        console.log('‚úÖ [Êô∫ËÉΩËß£Êûê] Áõ∏ÂØπ path Ëß£Êûê completeÔºåprocess ‰∫Ü', enhancedRelativeApis.length, '‰∏™Áõ∏ÂØπ path');
        console.log('üìä [Êô∫ËÉΩËß£Êûê] Ëß£Êûê statistics:', {
            ÊÄªÊï∞: enhancedRelativeApis.length,
            ÊàêÂäüËß£Êûê: enhancedRelativeApis.filter(item => item.resolvedUrl && item.resolvedUrl !== item.value).length,
            ‰ΩøÁî®IndexedDBÊï∞ÊçÆ: enhancedRelativeApis.filter(item => item.actualSourceUrl && item.actualSourceUrl !== currentSourceUrl).length
        });
        
    } catch (error) {
        console.error('‚ùå Êô∫ËÉΩÁõ∏ÂØπ path Ëß£Êûê failed:', error);
        // Âá∫ÈîôÊó∂‰øùÊåÅÂéüÂßã data do notÂèò
    }
}

// ËæÖÂä© functionÔºöËß£ÊûêÁõ∏ÂØπ path
function resolveRelativePath(relativePath, basePath) {
    try {
        if (!relativePath || !basePath) {
            console.warn('‚ö†Ô∏è Áõ∏ÂØπ path Ëß£Êûê parameter invalid:', { relativePath, basePath });
            return null;
        }
        
        console.log(`üîß [Ëß£Êûê] start Ëß£ÊûêÁõ∏ÂØπ path: "${relativePath}" Âü∫‰∫é "${basePath}"`);
        
        // Á°Æ‰øùbasePath‰ª•/ÁªìÂ∞æ
        if (!basePath.endsWith('/')) {
            basePath += '/';
        }
        
        let resolvedPath;
        
        if (relativePath.startsWith('./')) {
            // current ÁõÆÂΩïÔºö./file.js -> basePath + file.js
            resolvedPath = basePath + relativePath.substring(2);
            console.log(`üîß [Ëß£Êûê] current ÁõÆÂΩïËß£Êûê: "${relativePath}" -> "${resolvedPath}"`);
        } else if (relativePath.startsWith('../')) {
            // ‰∏äÁ∫ßÁõÆÂΩïÔºö../file.js -> require process path Â±ÇÁ∫ß
            const upLevels = (relativePath.match(/\.\.\//g) || []).length;
            const remainingPath = relativePath.replace(/\.\.\//g, '');
            
            console.log(`üîß [Ëß£Êûê] ‰∏äÁ∫ßÁõÆÂΩïËß£Êûê: Âêë‰∏ä${upLevels}Á∫ß, Ââ©‰Ωô path: "${remainingPath}"`);
            
            try {
                const baseUrlObj = new URL(basePath);
                const pathParts = baseUrlObj.pathname.split('/').filter(p => p);
                
                console.log(`üîß [Ëß£Êûê] basic path partial:`, pathParts);
                
                // Âêë‰∏äÁßªÂä®ÊåáÂÆöÂ±ÇÁ∫ß
                for (let i = 0; i < upLevels && pathParts.length > 0; i++) {
                    pathParts.pop();
                }
                
                console.log(`üîß [Ëß£Êûê] Âêë‰∏äÁßªÂä®Âêé path partial:`, pathParts);
                
                resolvedPath = `${baseUrlObj.protocol}//${baseUrlObj.host}/${pathParts.join('/')}${pathParts.length > 0 ? '/' : ''}${remainingPath}`;
                console.log(`üîß [Ëß£Êûê] ‰∏äÁ∫ßÁõÆÂΩïÊúÄÁªàËß£Êûê: "${relativePath}" -> "${resolvedPath}"`);
            } catch (e) {
                console.warn('‚ö†Ô∏è ‰∏äÁ∫ßÁõÆÂΩïËß£Êûê failedÔºåuse simple method:', e);
                // simple process ÊñπÂºè
                const baseUrl = basePath.split('/').slice(0, 3).join('/'); // protocol://host
                resolvedPath = baseUrl + '/' + remainingPath;
            }
        } else if (!relativePath.startsWith('/') && !relativePath.startsWith('http')) {
            // Áõ∏ÂØπ pathÔºöfile.js -> basePath + file.js
            resolvedPath = basePath + relativePath;
            console.log(`üîß [Ëß£Êûê] Áõ∏ÂØπ path Ëß£Êûê: "${relativePath}" -> "${resolvedPath}"`);
        } else {
            // alreadyÁªèÊòØÁªùÂØπ path
            resolvedPath = relativePath;
            console.log(`üîß [Ëß£Êûê] alreadyÊòØÁªùÂØπ path: "${relativePath}"`);
        }
        
        // cleanup Â§ö‰Ωô ÊñúÊù†
        const cleanedPath = resolvedPath.replace(/\/+/g, '/').replace(':/', '://');
        
        if (cleanedPath !== resolvedPath) {
            console.log(`üîß [Ëß£Êûê] path cleanup: "${resolvedPath}" -> "${cleanedPath}"`);
        }
        
        console.log(`‚úÖ [Ëß£Êûê] Áõ∏ÂØπ path Ëß£Êûê complete: "${relativePath}" -> "${cleanedPath}"`);
        return cleanedPath;
        
    } catch (error) {
        console.warn('‚ùå Áõ∏ÂØπ path Ëß£Êûê failed:', error, { relativePath, basePath });
        return null;
    }
}

// -------------------- ‰º†Áªü result processÔºàÂ§áÁî®Ôºâ --------------------
function convertRelativeApisToAbsolute(results) {
    // üî• fixÔºöÂÆåÂÖ® remove automatic convertÈÄªËæëÔºå‰øùÊåÅÁªùÂØπ path APIandÁõ∏ÂØπ path API Áã¨Á´ãÊÄß
    // do notÂÜçÂ∞ÜÁõ∏ÂØπ path API automatic convertÂπ∂ add Âà∞ÁªùÂØπ path APIin
    // ËøôÊ†∑ÂèØ‰ª•ÈÅøÂÖçÊÑèÂ§ñ add do notÁ¨¶ÂêàÁªùÂØπ path API regex Ë¶ÅÊ±Ç  data
    
    //console.log('üîç [DEBUG] APIconvert completeÔºàalready disable automatic convertÔºâ:');
    //console.log('  - keep Áõ∏ÂØπ path API:', results.relativeApis?.length || 0, '‰∏™');
    //console.log('  - keep ÁªùÂØπ path API:', results.absoluteApis?.length || 0, '‰∏™');
    
    // Â¶ÇÊûúrequireconvert featureÔºåÂ∫îËØ•inPatternExtractorinÈÄöthrough regular expression Êù•ÂÆûÁé∞
    // ËÄådo notÊòØinËøôÈáåËøõË°å force convert
}

// -------------------- performance optimization function --------------------
// ËäÇÊµÅ update display
function throttledUpdateDisplay() {
    const now = Date.now();
    if (now - lastUpdateTime < UPDATE_THROTTLE) {
        // Â¶ÇÊûúË∑ùÁ¶ª‰∏äÊ¨° update Êó∂Èó¥Â§™Áü≠Ôºådelay update
        if (updateTimer) {
            clearTimeout(updateTimer);
        }
        updateTimer = setTimeout(() => {
            performDisplayUpdate();
        }, UPDATE_THROTTLE);
        return;
    }
    
    performDisplayUpdate();
}

// execute display update
function performDisplayUpdate() {
    if (isUpdating) return;
    
    isUpdating = true;
    lastUpdateTime = Date.now();
    displayUpdateCount++;
    
    try {
        // use requestAnimationFrame Á°Æ‰øùin‰∏ã‰∏ÄÂ∏ß update
        requestAnimationFrame(() => {
            updateResultsDisplay();
            updateStatusDisplay();
            isUpdating = false;
        });
    } catch (error) {
        console.error('display update failed:', error);
        isUpdating = false;
    }
}

// batch process result ÂêàÂπ∂
function batchMergeResults(newResults) {
    let hasNewData = false;
    
    // Â∞ÜÊñ∞ result add Âà∞ÂæÖ process queue
    Object.keys(newResults).forEach(key => {
        if (!pendingResults[key]) {
            pendingResults[key] = new Map(); // useMapÊù• storage objectÔºå‰ª•valueto key ÈÅøÂÖçÈáçÂ§ç
        }
        
        if (Array.isArray(newResults[key])) {
            newResults[key].forEach(item => {
                if (item) {
                    // process ÁªìÊûÑÂåñ objectÔºàÂ∏¶sourceUrlÔºâand simple string
                    const itemKey = typeof item === 'object' ? item.value : item;
                    const itemData = typeof item === 'object' ? item : { value: item, sourceUrl: 'unknown' };
                    
                    if (!pendingResults[key].has(itemKey)) {
                        pendingResults[key].set(itemKey, itemData);
                        hasNewData = true;
                    }
                }
            });
        }
    });
    
    // Â¶ÇÊûúÊúâÊñ∞ dataÔºåËß¶ÂèëËäÇÊµÅ update
    if (hasNewData) {
        throttledUpdateDisplay();
    }
    
    return hasNewData;
}

// Â∞ÜÂæÖ process result ÂêàÂπ∂Âà∞‰∏ª result in
function flushPendingResults() {
    Object.keys(pendingResults).forEach(key => {
        if (!scanResults[key]) {
            scanResults[key] = [];
        }
        
        // ÂàõÂª∫Áé∞Êúâ result   key setÔºåforÂéªÈáç
        const existingKeys = new Set();
        scanResults[key].forEach(item => {
            const itemKey = typeof item === 'object' ? item.value : item;
            existingKeys.add(itemKey);
        });
        
        // add Êñ∞  result È°π
        pendingResults[key].forEach((itemData, itemKey) => {
            if (!existingKeys.has(itemKey)) {
                scanResults[key].push(itemData);
            }
        });
        
        // clear ÂæÖ process queue
        pendingResults[key].clear();
    });
}

// -------------------- page initialize --------------------
async function initializePage() {
    //console.log('üîç [DEBUG] page initialize in...');

    if (typeof chrome === 'undefined' || !chrome.storage) {
        console.error('‚ùå Chrome extension APIdo notÂèØÁî®');
        return;
    }

    await loadFilters();

    try {
        // Ëé∑ÂèñbaseUrlÔºàfrom scan configuration in baseUrlor current window  openerÔºâ
        let baseUrl = '';
        if (window.opener) {
            try {
                // Â∞ùËØïfromopener window Ëé∑ÂèñURL
                baseUrl = window.opener.location.origin;
            } catch (e) {
                // Â¶ÇÊûúË∑®ÂüüËÆøÈóÆ failedÔºåuse default ÊñπÂºè
                console.warn('Êó†Ê≥ïfromopenerËé∑ÂèñURLÔºåuse default ÊñπÂºè');
            }
        }
        
        // fromIndexedDB load deep scan configuration
        let deepScanConfig = null;
        if (baseUrl) {
            deepScanConfig = await window.IndexedDBManager.loadDeepScanState(baseUrl);
        }
        
        // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ configurationÔºåÂ∞ùËØïËé∑ÂèñallÂèØÁî®  configuration
        if (!deepScanConfig) {
            console.warn('‚ö†Ô∏è Êú™ÊâæÂà∞ÊåáÂÆöURL  scan configurationÔºåÂ∞ùËØïËé∑ÂèñallÂèØÁî® configuration ...');
            const allConfigs = await window.IndexedDBManager.getAllDeepScanStates();
            if (allConfigs && allConfigs.length > 0) {
                // useÊúÄÊñ∞  configuration
                deepScanConfig = allConfigs[allConfigs.length - 1];
                console.log('‚úÖ ÊâæÂà∞ÂèØÁî® configuration:', deepScanConfig.baseUrl);
            }
        }
        
        if (!deepScanConfig) throw new Error('Êú™ÊâæÂà∞ scan configuration');
        scanConfig = deepScanConfig;

        maxConcurrency = scanConfig.concurrency || 8;
        requestTimeout  = (scanConfig.timeout * 1000) || 5000;

        updateConfigDisplay();
        initializeScanResults();
    } catch (err) {
        console.error('‚ùå initialize failed:', err);
    }

    // ÁªëÂÆö button event
    document.getElementById('startBtn')?.addEventListener('click', startScan);
    document.getElementById('pauseBtn')?.addEventListener('click', pauseScan);
    document.getElementById('stopBtn')?.addEventListener('click', stopScan);
    document.getElementById('exportBtn')?.addEventListener('click', exportResults);
    document.getElementById('toggleAllBtn')?.addEventListener('click', toggleAllCategories);
    
    // üöÄ add ÊªöÂä® optimizationÔºöÊ£ÄÊµã user ÊòØÂê¶inÊªöÂä®
    const logSection = document.getElementById('logSection');
    if (logSection) {
        let scrollTimeout;
        logSection.addEventListener('scroll', () => {
            logSection.isUserScrolling = true;
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                logSection.isUserScrolling = false;
            }, 1000); // 1 secondsÂêéËÆ§to user ÂÅúÊ≠¢ÊªöÂä®
        });
        
        // üöÄ optimization ÊªöÂä® performance
        logSection.style.willChange = 'scroll-position';
        logSection.style.transform = 'translateZ(0)'; // enable Á°¨‰ª∂Âä†ÈÄü
    }

    // listen extension message
    chrome.runtime.onMessage.addListener((msg, sender, reply) => {
        if (msg.action === 'stopDeepScan') {
            stopScan();
            reply({ success: true });
        }
    });

    // automatic start
    setTimeout(startScan, 1000);
}

// -------------------- configuration display --------------------
function updateConfigDisplay() {
    if (!scanConfig) return;

    document.getElementById('maxDepthDisplay').textContent = scanConfig.maxDepth || 2;
    document.getElementById('concurrencyDisplay').textContent = scanConfig.concurrency || 8;
    document.getElementById('timeoutDisplay').textContent = scanConfig.timeout || 5;
    
    const scanTypes = [];
    if (scanConfig.scanJsFiles) scanTypes.push('JS file');
    if (scanConfig.scanHtmlFiles) scanTypes.push('HTML page');
    if (scanConfig.scanApiFiles) scanTypes.push('API interface');
    
    document.getElementById('scanTypesDisplay').textContent = scanTypes.join(', ') || 'all';
    document.getElementById('scanInfo').textContent = `ÁõÆÊ†á: ${scanConfig.baseUrl}`;
}

// -------------------- scan result initialize --------------------
function initializeScanResults() {
    scanResults = {
        absoluteApis: [],
        relativeApis: [],
        moduleApis: [],
        domains: [],
        urls: [],
        images: [],
        jsFiles: [],
        cssFiles: [],
        vueFiles: [],
        emails: [],
        phoneNumbers: [],
        ipAddresses: [],
        sensitiveKeywords: [],
        comments: [],
        paths: [],
        parameters: [],
        credentials: [],
        cookies: [],
        idKeys: [],
        companies: [],
        jwts: [],
        githubUrls: [],
        bearerTokens: [],
        basicAuth: [],
        authHeaders: [],
        wechatAppIds: [],
        awsKeys: [],
        googleApiKeys: [],
        githubTokens: [],
        gitlabTokens: [],
        webhookUrls: [],
        idCards: [],
        cryptoUsage: []
    };
}

// -------------------- scan ÊéßÂà∂ --------------------
async function startScan() {
    if (isScanRunning) return;
    
    //console.log('üöÄ [DEBUG] start deep scan ...');
    isScanRunning = true;
    isPaused = false;
    currentDepth = 0;
    scannedUrls.clear();
    pendingUrls.clear();
    urlContentCache.clear();
    
    // update UI status
    updateButtonStates();
    updateStatusDisplay();
    
    // hide load prompt
    document.getElementById('loadingDiv').style.display = 'none';
    
    try {
        // Êî∂ÈõÜÂàùÂßãURL
        const initialUrls = await collectInitialUrls();
        //console.log(`üìã [DEBUG] Êî∂ÈõÜÂà∞ ${initialUrls.length} ‰∏™ÂàùÂßãURL`);
        addLogEntry(`üìã Êî∂ÈõÜÂà∞ ${initialUrls.length} ‰∏™ÂàùÂßã scan URL`, 'info');
        
        if (initialUrls.length === 0) {
            addLogEntry('‚ö†Ô∏è Ê≤°ÊúâÊâæÂà∞can scan  URL', 'warning');
            return;
        }
        
        // üî• ËÆ∞ÂΩïÂàùÂßãURL listÔºàbeforeÂá†‰∏™Ôºâ
        if (initialUrls.length > 0) {
            const urlsToShow = initialUrls.slice(0, 5);
            addLogEntry(`üéØ ÂàùÂßã scan ÁõÆÊ†á: ${urlsToShow.join(', ')}${initialUrls.length > 5 ? ` Á≠â${initialUrls.length}‰∏™URL` : ''}`, 'info');
        }
        
        // ËÆ∞ÂΩï scan configuration
        addLogEntry(`‚öôÔ∏è scan configuration - maximum Ê∑±Â∫¶: ${scanConfig.maxDepth}, concurrent Êï∞: ${scanConfig.concurrency}, timeout: ${scanConfig.timeout}ms`, 'info');
        
        // start ÂàÜÂ±Ç scan
        await performLayeredScan(initialUrls);
        
        // complete scan
        completeScan();
        
    } catch (error) {
        console.error('‚ùå scan failed:', error);
        addLogEntry(`‚ùå scan failed: ${error.message}`, 'error');
    } finally {
        isScanRunning = false;
        updateButtonStates();
    }
}

function pauseScan() {
    isPaused = !isPaused;
    const pauseBtn = document.getElementById('pauseBtn');
    pauseBtn.textContent = isPaused ? 'ÁªßÁª≠ scan' : 'ÊöÇÂÅú scan';
    
    if (isPaused) {
        addLogEntry('‚è∏Ô∏è scan alreadyÊöÇÂÅú', 'warning');
        addLogEntry(`üìä ÊöÇÂÅúÊó∂ status: already scan ${scannedUrls.size} itemsURLÔºåcurrentÊ∑±Â∫¶${currentDepth}`, 'info');
    } else {
        addLogEntry('‚ñ∂Ô∏è scan alreadyÁªßÁª≠', 'success');
    }
}

function stopScan() {
    isScanRunning = false;
    isPaused = false;
    addLogEntry('‚èπÔ∏è user manual ÂÅúÊ≠¢ scan', 'warning');
    addLogEntry(`üìä ÂÅúÊ≠¢Êó∂ status: already scan ${scannedUrls.size} itemsURLÔºåcurrentÊ∑±Â∫¶${currentDepth}`, 'info');
    updateButtonStates();
    completeScan();
}

// -------------------- ÂàùÂßãURLÊî∂ÈõÜ --------------------
async function collectInitialUrls() {
    //console.log('üìã [DEBUG] start Êî∂ÈõÜÂàùÂßãURL - fromÊôÆÈÄö scan result inËé∑Âèñ');
    
    const urls = new Set();
    
    try {
        // from deep scan configuration inËé∑ÂèñÊôÆÈÄö scan   result
        if (!scanConfig.initialResults) {
            console.warn('‚ö†Ô∏è deep scan configuration inÊú™ÊâæÂà∞ÊôÆÈÄö scan resultÔºåÂ∞Ü scan current page');
            urls.add(scanConfig.baseUrl);
            return Array.from(urls);
        }
        
        const initialResults = scanConfig.initialResults;
        //console.log('üìä [DEBUG] ÊâæÂà∞ÊôÆÈÄö scan result:', Object.keys(initialResults));
        console.log('üìä [DEBUG] ÊôÆÈÄö scan result statistics:', {
            absoluteApis: initialResults.absoluteApis?.length || 0,
            jsFiles: initialResults.jsFiles?.length || 0,
            urls: initialResults.urls?.length || 0,
            domains: initialResults.domains?.length || 0,
            emails: initialResults.emails?.length || 0
        });
        
        // Â∞ÜÊôÆÈÄö scan result ‰Ωúto deep scan  Ëµ∑Âßã result
        Object.keys(initialResults).forEach(key => {
            if (scanResults[key] && Array.isArray(initialResults[key])) {
                scanResults[key] = [...initialResults[key]];
            }
        });
        
        // fromÊôÆÈÄö scan result inÊî∂ÈõÜJS file ËøõË°å deep scan
        if (scanConfig.scanJsFiles && initialResults.jsFiles) {
            //console.log(`üìÅ [DEBUG] fromÊôÆÈÄö scan result Êî∂ÈõÜJS file: ${initialResults.jsFiles.length} ‰∏™`);
            for (const jsFile of initialResults.jsFiles) {
                // ÂÖºÂÆπÊñ∞ formatÔºàobjectÔºâandÊóß formatÔºàstringÔºâ
                const url = typeof jsFile === 'object' ? jsFile.value : jsFile;
                const sourceUrl = typeof urlItem === 'object' ? urlItem.sourceUrl : null;
                const fullUrl = await resolveUrl(url, scanConfig.baseUrl, sourceUrl);
                if (fullUrl && await isSameDomain(fullUrl, scanConfig.baseUrl)) {
                    urls.add(fullUrl);
                    //console.log(`‚úÖ [DEBUG] add JS file: ${fullUrl}`);
                }
            }
        }
        
        // fromÊôÆÈÄö scan result inÊî∂ÈõÜHTML page ËøõË°å deep scan
        if (scanConfig.scanHtmlFiles && initialResults.urls) {
            //console.log(`üåê [DEBUG] fromÊôÆÈÄö scan result Êî∂ÈõÜURL: ${initialResults.urls.length} ‰∏™`);
            for (const urlItem of initialResults.urls) {
                // ÂÖºÂÆπÊñ∞ formatÔºàobjectÔºâandÊóß formatÔºàstringÔºâ
                const url = typeof urlItem === 'object' ? urlItem.value : urlItem;
                const sourceUrl = typeof urlItem === 'object' ? urlItem.sourceUrl : null;
                const fullUrl = await resolveUrl(url, scanConfig.baseUrl, sourceUrl);
                if (fullUrl && await isSameDomain(fullUrl, scanConfig.baseUrl) && isValidPageUrl(fullUrl)) {
                    urls.add(fullUrl);
                    //console.log(`‚úÖ [DEBUG] add page URL: ${fullUrl}`);
                }
            }
        }
        
        // fromÊôÆÈÄö scan result inÊî∂ÈõÜAPI interface ËøõË°å deep scan
        if (scanConfig.scanApiFiles) {
            // ÁªùÂØπ path API
            if (initialResults.absoluteApis) {
                //console.log(`üîó [DEBUG] fromÊôÆÈÄö scan result Êî∂ÈõÜÁªùÂØπAPI: ${initialResults.absoluteApis.length} ‰∏™`);
                for (const apiItem of initialResults.absoluteApis) {
                    // ÂÖºÂÆπÊñ∞ formatÔºàobjectÔºâandÊóß formatÔºàstringÔºâ
                    const api = typeof apiItem === 'object' ? apiItem.value : apiItem;
                    const sourceUrl = typeof apiItem === 'object' ? apiItem.sourceUrl : null;
                    const fullUrl = await resolveUrl(api, scanConfig.baseUrl, sourceUrl);
                    if (fullUrl && await isSameDomain(fullUrl, scanConfig.baseUrl)) {
                        urls.add(fullUrl);
                        //console.log(`‚úÖ [DEBUG] add ÁªùÂØπAPI: ${fullUrl}`);
                    }
                }
            }
            
            // Áõ∏ÂØπ path API
            if (initialResults.relativeApis) {
                //console.log(`üîó [DEBUG] fromÊôÆÈÄö scan result Êî∂ÈõÜÁõ∏ÂØπAPI: ${initialResults.relativeApis.length} ‰∏™`);
                for (const apiItem of initialResults.relativeApis) {
                    // ÂÖºÂÆπÊñ∞ formatÔºàobjectÔºâandÊóß formatÔºàstringÔºâ
                    const api = typeof apiItem === 'object' ? apiItem.value : apiItem;
                    const sourceUrl = typeof apiItem === 'object' ? apiItem.sourceUrl : null;
                    const fullUrl = await resolveUrl(api, scanConfig.baseUrl, sourceUrl);
                    if (fullUrl && await isSameDomain(fullUrl, scanConfig.baseUrl)) {
                        urls.add(fullUrl);
                        //console.log(`‚úÖ [DEBUG] add Áõ∏ÂØπAPI: ${fullUrl}`);
                    }
                }
            }
        }
        
        // Â¶ÇÊûúÊ≤°ÊúâÊî∂ÈõÜÂà∞‰ªª‰ΩïURLÔºåadd current page ‰ΩútoÂ§áÁî®
        if (urls.size === 0) {
            console.warn('‚ö†Ô∏è fromÊôÆÈÄö scan result inÊú™Êî∂ÈõÜÂà∞‰ªª‰ΩïURLÔºåadd current page');
            urls.add(scanConfig.baseUrl);
        }
        
        //console.log(`üìä [DEBUG] ÂàùÂßãURLÊî∂ÈõÜ completeÔºåÂÖ±Êî∂ÈõÜÂà∞ ${urls.size} ‰∏™URL`);
        //console.log(`üìä [DEBUG] ÂàùÂßã result count: ${Object.values(scanResults).reduce((sum, arr) => sum + (arr?.length || 0), 0)}`);
        return Array.from(urls);
        
    } catch (error) {
        console.error('‚ùå Êî∂ÈõÜÂàùÂßãURL failed:', error);
        // Âá∫ÈîôÊó∂ add current page ‰ΩútoÂ§áÁî®
        urls.add(scanConfig.baseUrl);
        return Array.from(urls);
    }
}

// -------------------- ÂàÜÂ±Ç scan --------------------
async function performLayeredScan(initialUrls) {
    let currentUrls = [...initialUrls];
    
    for (let depth = 1; depth <= scanConfig.maxDepth && isScanRunning; depth++) {
        currentDepth = depth;
        
        if (currentUrls.length === 0) {
            //console.log(`Á¨¨ ${depth} Â±ÇÊ≤°ÊúâURLrequire scan`);
            break;
        }
        
        //console.log(`üîç start Á¨¨ ${depth} Â±Ç scanÔºåURL count: ${currentUrls.length}`);
        addLogEntry(`üîç start Á¨¨ ${depth} Â±Ç scanÔºåURL count: ${currentUrls.length}`, 'info');
        
        // üî• ËÆ∞ÂΩï current Â±ÇË¶Å scan  URL listÔºàbeforeÂá†‰∏™Ôºâ
        if (currentUrls.length > 0) {
            const urlsToShow = currentUrls.slice(0, 3);
            addLogEntry(`üìã Á¨¨ ${depth} Â±Ç scan ÁõÆÊ†á: ${urlsToShow.join(', ')}${currentUrls.length > 3 ? ` Á≠â${currentUrls.length}‰∏™URL` : ''}`, 'info');
        }
        
        // batch scan URL
        const newUrls = await scanUrlBatch(currentUrls, depth);
        
        // ÂáÜÂ§á‰∏ã‰∏ÄÂ±ÇURL
        currentUrls = newUrls.filter(url => !scannedUrls.has(url));
        
        //console.log(`‚úÖ Á¨¨ ${depth} Â±Ç scan completeÔºåÂèëÁé∞Êñ∞URL: ${currentUrls.length} ‰∏™`);
        addLogEntry(`‚úÖ Á¨¨ ${depth} Â±Ç scan completeÔºåÂèëÁé∞Êñ∞URL: ${currentUrls.length} ‰∏™`, 'success');
        
        // üî• ËÆ∞ÂΩï‰∏ã‰∏ÄÂ±ÇÂ∞ÜË¶Å scan  URL count
        if (currentUrls.length > 0 && depth < scanConfig.maxDepth) {
            addLogEntry(`üîÑ ÂáÜÂ§áÁ¨¨ ${depth + 1} Â±Ç scanÔºåÂæÖ scan URL: ${currentUrls.length} ‰∏™`, 'info');
        }
        
        // update display
        updateResultsDisplay();
        updateStatusDisplay();
    }
}

// -------------------- batch URL scan --------------------
async function scanUrlBatch(urls, depth) {
    const newUrls = new Set();
    let processedCount = 0;
    const totalUrls = urls.length;
    
    // use queue and concurrent ÊéßÂà∂
    const queue = [...urls];
    const activeWorkers = new Set();
    
    // ÂÆûÊó∂ display ËÆ°Êï∞Âô®
    let lastDisplayUpdate = 0;
    const displayUpdateInterval = 500; // ÊØè0.5 secondsÊúÄÂ§ö update ‰∏ÄÊ¨° displayÔºåÊèêÈ´ò response ÈÄüÂ∫¶
    
    const processQueue = async () => {
        while (queue.length > 0 && isScanRunning && !isPaused) {
            const url = queue.shift();
            
            if (scannedUrls.has(url)) {
                processedCount++;
                updateProgressDisplay(processedCount, totalUrls, `Á¨¨ ${depth} Â±Ç scan`);
                continue;
            }
            
            scannedUrls.add(url);
            
            const workerPromise = (async () => {
                try {
                    // Ëé∑ÂèñURL content
                    let content;
                    if (urlContentCache.has(url)) {
                        content = urlContentCache.get(url);
                    } else {
                        content = await fetchUrlContent(url);
                        if (content) {
                            urlContentCache.set(url, content);
                        }
                    }
                    
                        if (content) {
                            // üöÄ performance optimizationÔºöremove È¢ëÁπÅ  scan log
                            // addLogEntry(`üîç Ê≠£in scan: ${url}`, 'info');
                            
                            // extract information
                            const extractedData = await extractFromContent(content, url);
                            const hasNewData = mergeResults(extractedData);
                            
                            // üî• ËÆ∞ÂΩï extract result log
                            if (hasNewData) {
                                const newDataCount = Object.values(extractedData).reduce((sum, arr) => sum + (arr?.length || 0), 0);
                                addLogEntry(`‚úÖ from ${url} extract Âà∞ ${newDataCount} ‰∏™Êñ∞ data È°π`, 'success');
                            } else {
                                addLogEntry(`‚ÑπÔ∏è from ${url} Êú™ÂèëÁé∞Êñ∞ data`, 'info');
                            }
                            
                            // üöÄ performance optimizationÔºöreduce display update È¢ëÁéáÔºåÂè™in batch process Êó∂ update
                            if (hasNewData) {
                                // ÊØè process 10 itemsURLÊâç update ‰∏ÄÊ¨° display
                                if (processedCount % 10 === 0) {
                                    throttledUpdateDisplay();
                                }
                            }
                            
                            // Êî∂ÈõÜÊñ∞URL
                            const discoveredUrls = await collectUrlsFromContent(content, scanConfig.baseUrl);
                            if (discoveredUrls.length > 0) {
                                addLogEntry(`üîó from ${url} ÂèëÁé∞ ${discoveredUrls.length} ‰∏™Êñ∞URL`, 'info');
                            }
                            discoveredUrls.forEach(newUrl => newUrls.add(newUrl));
                        } else {
                            // üî• ËÆ∞ÂΩïÊó† content  ÊÉÖÂÜµ
                            addLogEntry(`‚ö†Ô∏è ${url} ËøîÂõû empty content orÊó†Ê≥ïËÆøÈóÆ`, 'warning');
                        }
                    } catch (error) {
                        console.error(`scan ${url} failed:`, error);
                        // üî• add error log ËÆ∞ÂΩï
                        addLogEntry(`‚ùå scan failed: ${url} - ${error.message}`, 'error');
                    } finally {
                        processedCount++;
                        // üöÄ performance optimizationÔºöreduceËøõÂ∫¶ update È¢ëÁéáÔºåÊØè5 itemsURL update ‰∏ÄÊ¨°
                        if (processedCount % 5 === 0 || processedCount === totalUrls) {
                            updateProgressDisplay(processedCount, totalUrls, `Á¨¨ ${depth} Â±Ç scan`);
                        }
                        activeWorkers.delete(workerPromise);
                    }
            })();
            
            activeWorkers.add(workerPromise);
            
            // üöÄ performance optimizationÔºöÊéßÂà∂ concurrent Êï∞Âπ∂ add delay
            if (activeWorkers.size >= maxConcurrency) {
                await Promise.race(Array.from(activeWorkers));
            }
            
            // add delayÔºåÈÅøÂÖçthroughÂø´ request ÂØºËá¥ system Âç°È°ø
            if (activeWorkers.size >= maxConcurrency) {
                await new Promise(resolve => setTimeout(resolve, 100)); // üöÄ Â¢ûÂä†Âà∞200ms delay
            }
        }
    };
    
    await processQueue();
    
    // wait allÂ∑•‰Ωú complete
    if (activeWorkers.size > 0) {
        await Promise.all(Array.from(activeWorkers));
    }
    
    return Array.from(newUrls);
}

// -------------------- URL content Ëé∑Âèñ --------------------
async function fetchUrlContent(url) {
    try {
        //console.log(`üî• deep scan - ÂáÜÂ§áÈÄöthroughbackground script request: ${url}`);
        
        const requestOptions = {
            method: 'GET',
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml,text/javascript,application/javascript,text/css,*/*',
                'Cache-Control': 'no-cache'
            },
            timeout: requestTimeout
        };
        
        const response = await makeRequestViaBackground(url, requestOptions);
        
        if (!response.ok) {
            console.warn(`HTTP ${response.status} for ${url}`);
            // üî• addHTTPerrorÊó•Âøó
            addLogEntry(`‚ö†Ô∏è HTTP ${response.status} - ${url}`, 'warning');
            return null;
        }
        
        const contentType = response.headers.get('content-type') || '';
        // filter Èùû text content
        if (contentType.includes('image/') || 
            contentType.includes('audio/') || 
            contentType.includes('video/') || 
            contentType.includes('application/octet-stream') ||
            contentType.includes('application/zip') ||
            contentType.includes('application/pdf')) {
            // üî• add content type filter log
            addLogEntry(`üö´ skipÈùû text content (${contentType}) - ${url}`, 'info');
            return null;
        }
        
        const text = await response.text();
        // üî• add success Ëé∑Âèñ content   log
        const contentSize = text.length;
        const sizeText = contentSize > 1024 ? `${Math.round(contentSize / 1024)}KB` : `${contentSize}B`;
        addLogEntry(`üì• success Ëé∑Âèñ content (${sizeText}) - ${url}`, 'info');
        return text;
        
    } catch (error) {
        console.error(`Êó†Ê≥ïËÆøÈóÆ ${url}:`, error);
        // üî• add network error log
        addLogEntry(`‚ùå network error: ${error.message} - ${url}`, 'error');
        return null;
    }
}

// -------------------- background request --------------------
async function makeRequestViaBackground(url, options = {}) {
    return new Promise((resolve, reject) => {
        chrome.runtime.sendMessage({
            action: 'makeRequest',
            url: url,
            options: options
        }, (response) => {
            if (chrome.runtime.lastError) {
                reject(new Error(chrome.runtime.lastError.message));
            } else if (response && response.success) {
                const mockHeaders = new Map(Object.entries(response.data.headers || {}));
                
                resolve({
                    ok: response.data.status >= 200 && response.data.status < 300,
                    status: response.data.status,
                    statusText: response.data.statusText,
                    headers: {
                        get: (name) => mockHeaders.get(name.toLowerCase()),
                        has: (name) => mockHeaders.has(name.toLowerCase()),
                        entries: () => mockHeaders.entries(),
                        keys: () => mockHeaders.keys(),
                        values: () => mockHeaders.values()
                    },
                    text: () => Promise.resolve(response.data.text),
                    json: () => {
                        try {
                            return Promise.resolve(JSON.parse(response.data.text));
                        } catch (e) {
                            return Promise.reject(new Error('Invalid JSON'));
                        }
                    },
                    url: response.data.url
                });
            } else {
                reject(new Error(response?.error || 'Request failed'));
            }
        });
    });
}

// -------------------- from content Êî∂ÈõÜURL --------------------
async function collectUrlsFromContent(content, baseUrl) {
    const urls = new Set();
    
    try {
        const extractedData = await extractFromContent(content, baseUrl);
        
        // Êî∂ÈõÜJS file
        if (scanConfig.scanJsFiles && extractedData.jsFiles) {
            for (const jsFileItem of extractedData.jsFiles) {
                const jsFile = typeof jsFileItem === 'object' ? jsFileItem.value : jsFileItem;
                const sourceUrl = typeof jsFileItem === 'object' ? jsFileItem.sourceUrl : null;
                const fullUrl = await resolveUrl(jsFile, baseUrl, sourceUrl);
                if (fullUrl && await isSameDomain(fullUrl, baseUrl)) {
                    urls.add(fullUrl);
                }
            }
        }
        
        // Êî∂ÈõÜHTML page
        if (scanConfig.scanHtmlFiles && extractedData.urls) {
            for (const urlItem of extractedData.urls) {
                const url = typeof urlItem === 'object' ? urlItem.value : urlItem;
                const sourceUrl = typeof urlItem === 'object' ? urlItem.sourceUrl : null;
                const fullUrl = await resolveUrl(url, baseUrl, sourceUrl);
                if (fullUrl && await isSameDomain(fullUrl, baseUrl) && isValidPageUrl(fullUrl)) {
                    urls.add(fullUrl);
                }
            }
        }
        
        // Êî∂ÈõÜAPI interface - useÊô∫ËÉΩËß£Êûê
        if (scanConfig.scanApiFiles) {
            if (extractedData.absoluteApis) {
                for (const apiItem of extractedData.absoluteApis) {
                    const api = typeof apiItem === 'object' ? apiItem.value : apiItem;
                    const sourceUrl = typeof apiItem === 'object' ? apiItem.sourceUrl : null;
                    const fullUrl = await resolveUrl(api, baseUrl, sourceUrl);
                    if (fullUrl && await isSameDomain(fullUrl, baseUrl)) {
                        urls.add(fullUrl);
                    }
                }
            }
            
            if (extractedData.relativeApis) {
                for (const apiItem of extractedData.relativeApis) {
                    // üî• ‰ºòÂÖàuseÊô∫ËÉΩËß£Êûê  URL
                    let fullUrl;
                    if (typeof apiItem === 'object' && apiItem.resolvedUrl) {
                        fullUrl = apiItem.resolvedUrl;
                        //console.log('üéØ [DEBUG] useÊô∫ËÉΩËß£ÊûêURL:', apiItem.value, '->', fullUrl);
                    } else {
                        const api = typeof apiItem === 'object' ? apiItem.value : apiItem;
                        const sourceUrl = typeof apiItem === 'object' ? apiItem.sourceUrl : null;
                        fullUrl = await resolveUrl(api, baseUrl, sourceUrl);
                        //console.log('üîÑ [DEBUG] use‰º†ÁªüËß£ÊûêURL:', api, '->', fullUrl);
                    }
                    
                    if (fullUrl && await isSameDomain(fullUrl, baseUrl)) {
                        urls.add(fullUrl);
                    }
                }
            }
        }
    } catch (error) {
        console.error('‚ùå from content Êî∂ÈõÜURL failed:', error);
    }
    
    return Array.from(urls);
}

// -------------------- result ÂêàÂπ∂ --------------------
function mergeResults(newResults) {
    // use batch ÂêàÂπ∂ÔºåÈÅøÂÖçÈ¢ëÁπÅ DOM update
    return batchMergeResults(newResults);
}

// -------------------- result save --------------------
async function saveResultsToStorage() {
    try {
        // ÁîüÊàê domain key
        let domainKey = 'unknown__results';
        if (scanConfig?.baseUrl) {
            try {
                const hostname = new URL(scanConfig.baseUrl).hostname;
                domainKey = `${hostname}__results`;
            } catch (e) {
                console.warn('Ëß£Êûê domain failedÔºåuse default key:', e);
            }
        }
        
        //console.log('üìù [DEBUG] use storage key:', domainKey);
        
        // fromIndexedDBËé∑Âèñ current  ÊôÆÈÄö scan result
        const existingResults = await window.IndexedDBManager.loadScanResults(scanConfig.baseUrl) || {};
        
        // ÂêàÂπ∂ deep scan result Âà∞ÊôÆÈÄö scan result in
        const mergedResults = { ...existingResults };
        
        // Â∞Ü deep scan   result ÂêàÂπ∂Âà∞ÊôÆÈÄö scan result in
        Object.keys(scanResults).forEach(key => {
            if (!mergedResults[key]) {
                mergedResults[key] = [];
            }
            
            // ÂàõÂª∫Áé∞Êúâ result   key setÔºåforÂéªÈáç
            const existingKeys = new Set();
            mergedResults[key].forEach(item => {
                const itemKey = typeof item === 'object' ? item.value : item;
                existingKeys.add(itemKey);
            });
            
            // ÂêàÂπ∂Êñ∞  result È°π
            scanResults[key].forEach(item => {
                if (item) {
                    const itemKey = typeof item === 'object' ? item.value : item;
                    if (!existingKeys.has(itemKey)) {
                        mergedResults[key].push(item);
                        existingKeys.add(itemKey);
                    }
                }
            });
        });
        
        // add scan ÂÖÉ data
        mergedResults.scanMetadata = {
            ...existingResults.scanMetadata,
            lastScanType: 'deep',
            deepScanComplete: true,
            deepScanTimestamp: Date.now(),
            deepScanUrl: scanConfig.baseUrl,
            totalScanned: scannedUrls.size
        };
        
        // save ÂêàÂπ∂Âêé  result Âà∞IndexedDBÔºåcontains URL‰ΩçÁΩÆ information
        const pageTitle = scanConfig.pageTitle || document.title || 'Deep Scan Results';
        // usebasicURL‰Ωúto storage keyÔºå‰ΩÜ‰øùÊåÅÊØè‰∏™ result È°π ÂÖ∑‰ΩìÊù•Ê∫êURL
        await window.IndexedDBManager.saveScanResults(scanConfig.baseUrl, mergedResults, scanConfig.baseUrl, pageTitle);
        
        //console.log('‚úÖ deep scan result alreadyÂêàÂπ∂Âà∞‰∏ª scan result in');
        //console.log('üìä storage key:', domainKey);
        console.log('üìä ÂêàÂπ∂Âêé result statistics:', {
            ÊÄªÊï∞: Object.values(mergedResults).reduce((sum, arr) => {
                return sum + (Array.isArray(arr) ? arr.length : 0);
            }, 0),
            Ê∑±Â∫¶Êâ´ÊèèË¥°ÁåÆ: Object.values(scanResults).reduce((sum, arr) => sum + (arr?.length || 0), 0)
        });
        
    } catch (error) {
        console.error('‚ùå save result failed:', error);
    }
}

// -------------------- scan complete --------------------
async function completeScan() {
    //console.log('üéâ deep scan completeÔºÅ');
    
    // üî• optimizationÔºöÁ°Æ‰øùallÂæÖ process result ÈÉΩpassive markerÂêàÂπ∂
    flushPendingResults();
    
    const totalResults = Object.values(scanResults).reduce((sum, arr) => sum + (arr?.length || 0), 0);
    const totalScanned = scannedUrls.size;
    
    addLogEntry('üéâ deep scan completeÔºÅ', 'success');
    addLogEntry(`üìä scan statistics: scan ‰∫Ü ${totalScanned} ‰∏™ fileÔºåextract ‰∫Ü ${totalResults} ‰∏™È°πÁõÆ`, 'success');
    
    // üî• optimizationÔºöreduce detailed statistics logÔºåÈÅøÂÖçÂç°È°ø
    const nonEmptyCategories = Object.entries(scanResults).filter(([key, items]) => items && items.length > 0);
    if (nonEmptyCategories.length > 0) {
        const topCategories = nonEmptyCategories
            .sort(([,a], [,b]) => b.length - a.length)
            .slice(0, 5) // Âè™ display before5 itemsÊúÄÂ§ö Á±ªÂà´
            .map(([key, items]) => `${key}: ${items.length} items`);
        addLogEntry(`üìà ‰∏ªË¶ÅÂèëÁé∞: ${topCategories.join(', ')}`, 'success');
    }
    
    // üî• ËÆ∞ÂΩï scan ËÄóÊó∂
    const scanDuration = Date.now() - (scanConfig.timestamp || Date.now());
    const durationText = scanDuration > 60000 ? 
        `${Math.floor(scanDuration / 60000)}ÂàÜ${Math.floor((scanDuration % 60000) / 1000)}Áßí` : 
        `${Math.floor(scanDuration / 1000)}Áßí`;
    addLogEntry(`‚è±Ô∏è scan ËÄóÊó∂: ${durationText}`, 'info');
    
    // save result Âà∞ storageÔºàÂêàÂπ∂Âà∞‰∏ª scan result inÔºâ
    await saveResultsToStorage();
    
    // notification ‰∏ª page deep scan completeÔºåËÆ©ÂÖ∂ update display
    try {
        chrome.runtime.sendMessage({
            action: 'deepScanComplete',
            data: {
                results: scanResults,
                totalScanned: totalScanned,
                totalResults: totalResults,
                baseUrl: scanConfig.baseUrl
            }
        }, (response) => {
            if (chrome.runtime.lastError) {
                //console.log('‰∏ª page ÂèØËÉΩalready closeÔºåÊó†Ê≥ïÂèëÈÄÅ complete notification');
            } else {
                //console.log('‚úÖ already notification ‰∏ª page deep scan complete');
            }
        });
    } catch (error) {
        //console.log('ÂèëÈÄÅ complete notification failed:', error);
    }
    
    // üî• optimizationÔºöÊúÄÁªà update UI
    performDisplayUpdate();
    
    // update ËøõÂ∫¶ display
    const progressText = document.getElementById('progressText');
    if (progressText) {
        progressText.textContent = '‚úÖ deep scan completeÔºÅ';
        progressText.classList.add('success');
    }
    
    const progressBar = document.getElementById('progressBar');
    if (progressBar) {
        progressBar.style.width = '100%';
    }
    
    // update button status
    updateButtonStates();
    
    // üî• optimizationÔºöcleanup ÂÜÖÂ≠òand cache
    setTimeout(() => {
        cleanupMemory();
    }, 5000); // 5 secondsÂêé cleanup ÂÜÖÂ≠ò
}

// ÂÜÖÂ≠ò cleanup function
function cleanupMemory() {
    //console.log('üßπ start cleanup ÂÜÖÂ≠ò...');
    
    // cleanup URL content cacheÔºåÂè™keepÊúÄËøë 100 items
    if (urlContentCache.size > 100) {
        const entries = Array.from(urlContentCache.entries());
        const toKeep = entries.slice(-100);
        urlContentCache.clear();
        toKeep.forEach(([key, value]) => urlContentCache.set(key, value));
        //console.log(`üßπ cleanup URL cacheÔºåkeep ${toKeep.length} ‰∏™Êù°ÁõÆ`);
    }
    
    // cleanup ÂæÖ process result
    Object.keys(pendingResults).forEach(key => {
        if (pendingResults[key]) {
            pendingResults[key].clear();
        }
    });
    
    // cleanup update queue
    updateQueue.length = 0;
    
    // cleanup ÂÆöÊó∂Âô®
    if (updateTimer) {
        clearTimeout(updateTimer);
        updateTimer = null;
    }
    
    //console.log('‚úÖ ÂÜÖÂ≠ò cleanup complete');
}

// -------------------- UI update function --------------------
function updateButtonStates() {
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    
    if (isScanRunning) {
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        stopBtn.disabled = false;
        startBtn.textContent = 'scan in...';
        pauseBtn.textContent = isPaused ? 'ÁªßÁª≠ scan' : 'ÊöÇÂÅú scan';
    } else {
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        stopBtn.disabled = true;
        startBtn.textContent = 'start scan';
        pauseBtn.textContent = 'ÊöÇÂÅú scan';
    }
}

function updateStatusDisplay() {
    document.getElementById('currentDepth').textContent = currentDepth;
    document.getElementById('scannedUrls').textContent = scannedUrls.size;
    document.getElementById('pendingUrls').textContent = pendingUrls.size;
    
    const totalResults = Object.values(scanResults).reduce((sum, arr) => sum + (arr?.length || 0), 0);
    document.getElementById('totalResults').textContent = totalResults;
}

function updateProgressDisplay(current, total, stage) {
    // üöÄ Èò≤Êäñ processÔºöÈÅøÂÖçÈ¢ëÁπÅ update ËøõÂ∫¶Êù°
    if (updateProgressDisplay.pending) return;
    updateProgressDisplay.pending = true;
    
    // üöÄ userequestAnimationFrame delay updateÔºåÈÅøÂÖç blocking ÊªöÂä®
    requestAnimationFrame(() => {
        const progressText = document.getElementById('progressText');
        const progressBar = document.getElementById('progressBar');
        
        if (progressText && progressBar) {
            const percentage = total > 0 ? (current / total) * 100 : 0;
            progressText.textContent = `${stage}: ${current}/${total} (${percentage.toFixed(1)}%)`;
            progressBar.style.width = `${percentage}%`;
        }
        
        updateProgressDisplay.pending = false;
    });
}

function updateResultsDisplay() {
    // ÂÖàÂêàÂπ∂allÂæÖ process   result
    flushPendingResults();
    
    //console.log(`üîç [DEBUG] start update deep scan result display ... (Á¨¨${displayUpdateCount}Ê¨°update)`);
    
    // üî• reduce debug log ËæìÂá∫ÔºåÈÅøÂÖçÊéßÂà∂Âè∞Âç°È°ø
    if (displayUpdateCount % 10 === 0) { // ÊØè10Ê¨° update ÊâçËæìÂá∫ detailed log
        //console.log('üîç [DEBUG] API data check:');
        //console.log('  - absoluteApis:', scanResults.absoluteApis?.length || 0, '‰∏™');
        //console.log('  - relativeApis:', scanResults.relativeApis?.length || 0, '‰∏™');
        if (scanResults.absoluteApis?.length > 0) {
            //console.log('  - absoluteApis example:', scanResults.absoluteApis.slice(0, 3));
        }
        if (scanResults.relativeApis?.length > 0) {
            //console.log('  - relativeApis example:', scanResults.relativeApis.slice(0, 3));
        }
    }
    
    // üî• fixAPI display issueÔºöÊ≠£Á°Æ ÂÖÉÁ¥†ID map
    const categoryMapping = {
        absoluteApis: { containerId: 'absoluteApisResult', countId: 'absoluteApisCount', listId: 'absoluteApisList' },
        relativeApis: { containerId: 'relativeApisResult', countId: 'relativeApisCount', listId: 'relativeApisList' },
        moduleApis: { containerId: 'modulePathsResult', countId: 'modulePathsCount', listId: 'modulePathsList' },
        domains: { containerId: 'domainsResult', countId: 'domainsCount', listId: 'domainsList' },
        urls: { containerId: 'urlsResult', countId: 'urlsCount', listId: 'urlsList' },
        images: { containerId: 'imagesResult', countId: 'imagesCount', listId: 'imagesList' },
        jsFiles: { containerId: 'jsFilesResult', countId: 'jsFilesCount', listId: 'jsFilesList' },
        cssFiles: { containerId: 'cssFilesResult', countId: 'cssFilesCount', listId: 'cssFilesList' },
        vueFiles: { containerId: 'vueFilesResult', countId: 'vueFilesCount', listId: 'vueFilesList' },
        emails: { containerId: 'emailsResult', countId: 'emailsCount', listId: 'emailsList' },
        phoneNumbers: { containerId: 'phoneNumbersResult', countId: 'phoneNumbersCount', listId: 'phoneNumbersList' },
        ipAddresses: { containerId: 'ipAddressesResult', countId: 'ipAddressesCount', listId: 'ipAddressesList' },
        sensitiveKeywords: { containerId: 'sensitiveKeywordsResult', countId: 'sensitiveKeywordsCount', listId: 'sensitiveKeywordsList' },
        comments: { containerId: 'commentsResult', countId: 'commentsCount', listId: 'commentsList' },
        paths: { containerId: 'pathsResult', countId: 'pathsCount', listId: 'pathsList' },
        parameters: { containerId: 'parametersResult', countId: 'parametersCount', listId: 'parametersList' },
        credentials: { containerId: 'credentialsResult', countId: 'credentialsCount', listId: 'credentialsList' },
        cookies: { containerId: 'cookiesResult', countId: 'cookiesCount', listId: 'cookiesList' },
        idKeys: { containerId: 'idKeysResult', countId: 'idKeysCount', listId: 'idKeysList' },
        companies: { containerId: 'companiesResult', countId: 'companiesCount', listId: 'companiesList' },
        jwts: { containerId: 'jwtsResult', countId: 'jwtsCount', listId: 'jwtsList' },
        githubUrls: { containerId: 'githubUrlsResult', countId: 'githubUrlsCount', listId: 'githubUrlsList' },
        bearerTokens: { containerId: 'bearerTokensResult', countId: 'bearerTokensCount', listId: 'bearerTokensList' },
        basicAuth: { containerId: 'basicAuthResult', countId: 'basicAuthCount', listId: 'basicAuthList' },
        authHeaders: { containerId: 'authHeadersResult', countId: 'authHeadersCount', listId: 'authHeadersList' },
        wechatAppIds: { containerId: 'wechatAppIdsResult', countId: 'wechatAppIdsCount', listId: 'wechatAppIdsList' },
        awsKeys: { containerId: 'awsKeysResult', countId: 'awsKeysCount', listId: 'awsKeysList' },
        googleApiKeys: { containerId: 'googleApiKeysResult', countId: 'googleApiKeysCount', listId: 'googleApiKeysList' },
        githubTokens: { containerId: 'githubTokensResult', countId: 'githubTokensCount', listId: 'githubTokensList' },
        gitlabTokens: { containerId: 'gitlabTokensResult', countId: 'gitlabTokensCount', listId: 'gitlabTokensList' },
        webhookUrls: { containerId: 'webhookUrlsResult', countId: 'webhookUrlsCount', listId: 'webhookUrlsList' },
        idCards: { containerId: 'idCardsResult', countId: 'idCardsCount', listId: 'idCardsList' },
        cryptoUsage: { containerId: 'cryptoUsageResult', countId: 'cryptoUsageCount', listId: 'cryptoUsageList' }
    };
    
    // üî• fix display ÈÄªËæëÔºöuseÊ≠£Á°Æ ÂÖÉÁ¥†ID
    Object.keys(categoryMapping).forEach(key => {
        const items = scanResults[key] || [];
        const mapping = categoryMapping[key];
        
        // üî• optimizationÔºöreduce debug logÔºåÂè™inÂøÖË¶ÅÊó∂ËæìÂá∫
        if (displayUpdateCount % 20 === 0) {
            //console.log(`üîç [DEBUG] process Á±ªÂà´ ${key}: ${items.length} ‰∏™È°πÁõÆ`);
        }
        
        if (items.length > 0) {
            // display ÂÆπÂô®
            const resultDiv = document.getElementById(mapping.containerId);
            if (resultDiv) {
                resultDiv.style.display = 'block';
            }
            
            // update ËÆ°Êï∞
            const countElement = document.getElementById(mapping.countId);
            if (countElement && countElement.textContent !== items.length.toString()) {
                countElement.textContent = items.length;
            }
            
            // üî• optimizationÔºöÂè™in list content ÁúüÊ≠£ÊîπÂèòÊó∂Êâç update DOM
            const listElement = document.getElementById(mapping.listId);
            if (listElement) {
                const currentItemCount = listElement.children.length;
                if (currentItemCount !== items.length) {
                    // use documentation ÁâáÊÆµ batch update DOM
                    const fragment = document.createDocumentFragment();
                    items.forEach((item, index) => {
                        const li = document.createElement('li');
                        li.className = 'result-item';
                        
                        // üî• fixÔºöuseÊØè‰∏™È°πÁõÆËá™Â∑± sourceUrlËøõË°åÊÇ¨ÂÅú displayÔºåsupportÊô∫ËÉΩËß£Êûê URL
                        if (typeof item === 'object' && item !== null) {
                            // process Â∏¶ÊúâsourceUrl ÁªìÊûÑÂåñ object {value: '/fly/user/login', sourceUrl: 'http://notify.dinnovate.cn/assets/index.esm-USutLI8H.js'}
                            if (item.value !== undefined && item.sourceUrl) {
                                const itemValue = String(item.value);
                                const itemSourceUrl = String(item.sourceUrl);
                                
                                // üî• Êñ∞Â¢ûÔºöÂ¶ÇÊûúÊòØÁõ∏ÂØπ path API‰∏îÊúâÊô∫ËÉΩËß£Êûê URLÔºådisplay È¢ùÂ§ñ information
                                if (key === 'relativeApis' && item.resolvedUrl) {
                                    li.innerHTML = `<span class="result-value">${itemValue}</span> <span class="resolved-url" style="color: #666; font-size: 0.9em;">‚Üí ${item.resolvedUrl}</span>`;
                                    li.title = `ÂéüÂßãÂÄº: ${itemValue}
Êô∫ËÉΩËß£Êûê: ${item.resolvedUrl}
Êù•Ê∫ê: ${itemSourceUrl}`;
                                } else {
                                    // Âè™ display valueÔºådo notdirectly display Êù•Ê∫êURLÔºå‰ªÖinÊÇ¨ÂÅúÊó∂ display
                                    li.innerHTML = `<span class="result-value">${itemValue}</span>`;
                                    li.title = `Êù•Ê∫ê: ${itemSourceUrl}`;
                                }
                                li.style.cssText = 'padding: 5px 0;';
                            } else if (item.url || item.path || item.value || item.content) {
                                // ÂÖºÂÆπÂÖ∂‰ªñ object format
                                const displayValue = item.url || item.path || item.value || item.content || JSON.stringify(item);
                                li.textContent = String(displayValue);
                                li.title = String(displayValue);
                            } else {
                                const jsonStr = JSON.stringify(item);
                                li.textContent = jsonStr;
                                li.title = jsonStr;
                            }
                        } else {
                            // Â¶ÇÊûúÊòØ string orÂÖ∂‰ªñÂü∫Êú¨ typeÔºådirectly display
                            const displayValue = String(item);
                            li.textContent = displayValue;
                            li.title = displayValue;
                        }
                        
                        fragment.appendChild(li);
                    });
                    
                    // ‰∏ÄÊ¨°ÊÄß update DOM
                    listElement.innerHTML = '';
                    listElement.appendChild(fragment);
                }
            }
        }
    });
    
    // üî• process custom regex result - ÊÅ¢Â§çpassive marker delete   feature
    //console.log('üîç [DEBUG] start process custom regex result ...');
    Object.keys(scanResults).forEach(key => {
        if (key.startsWith('custom_') && scanResults[key]?.length > 0) {
            //console.log(`üéØ [DEBUG] ÂèëÁé∞ custom regex result: ${key}, count: ${scanResults[key].length}`);
            createCustomResultCategory(key, scanResults[key]);
        }
    });
    
    // üî• process ÂÖ∂‰ªñÊú™È¢ÑÂÆö‰πâ  result Á±ªÂà´
    Object.keys(scanResults).forEach(key => {
        // skipalready process  È¢ÑÂÆö‰πâÁ±ªÂà´and custom regex
        if (!categoryMapping[key] && !key.startsWith('custom_') && scanResults[key]?.length > 0) {
            //console.log(`üÜï [DEBUG] ÂèëÁé∞Êñ∞  result Á±ªÂà´: ${key}, count: ${scanResults[key].length}`);
            createCustomResultCategory(key, scanResults[key]);
        }
    });
}

function createCustomResultCategory(key, items) {
    const resultsSection = document.getElementById('resultsSection');
    if (!resultsSection) return;
    
    let resultDiv = document.getElementById(key + 'Result');
    if (!resultDiv) {
        resultDiv = document.createElement('div');
        resultDiv.id = key + 'Result';
        resultDiv.className = 'result-category';
        
        const title = document.createElement('h3');
        title.innerHTML = `üîç ${key.replace('custom_', 'custom -')} (<span id="${key}Count">0</span>)`;
        
        const list = document.createElement('ul');
        list.id = key + 'List';
        list.className = 'result-list';
        
        resultDiv.appendChild(title);
        resultDiv.appendChild(list);
        resultsSection.appendChild(resultDiv);
    }
    
    resultDiv.style.display = 'block';
    
    const countElement = document.getElementById(key + 'Count');
    if (countElement) {
        countElement.textContent = items.length;
    }
    
    const listElement = document.getElementById(key + 'List');
    if (listElement) {
        listElement.innerHTML = '';
        items.forEach(item => {
            const li = document.createElement('li');
            li.className = 'result-item';
            
            // üî• fixÔºöuseÊØè‰∏™È°πÁõÆËá™Â∑± sourceUrlËøõË°åÊÇ¨ÂÅú displayÔºåsupportÊô∫ËÉΩËß£Êûê URL
            if (typeof item === 'object' && item !== null) {
                // process Â∏¶ÊúâsourceUrl ÁªìÊûÑÂåñ object {value: '/fly/user/login', sourceUrl: 'http://notify.dinnovate.cn/assets/index.esm-USutLI8H.js'}
                if (item.value !== undefined && item.sourceUrl) {
                    const itemValue = String(item.value);
                    const itemSourceUrl = String(item.sourceUrl);
                    
                    // üî• Êñ∞Â¢ûÔºöÂ¶ÇÊûúÊòØÁõ∏ÂØπ path API‰∏îÊúâÊô∫ËÉΩËß£Êûê URLÔºådisplay È¢ùÂ§ñ information
                    if (key === 'relativeApis' && item.resolvedUrl) {
                        li.innerHTML = `<span class="result-value">${itemValue}</span> <span class="resolved-url" style="color: #666; font-size: 0.9em;">‚Üí ${item.resolvedUrl}</span>`;
                        li.title = `ÂéüÂßãÂÄº: ${itemValue}
Êô∫ËÉΩËß£Êûê: ${item.resolvedUrl}
Êù•Ê∫ê: ${itemSourceUrl}`;
                    } else {
                        // Âè™ display valueÔºådo notdirectly display Êù•Ê∫êURLÔºå‰ªÖinÊÇ¨ÂÅúÊó∂ display
                        li.innerHTML = `<span class="result-value">${itemValue}</span>`;
                        li.title = `Êù•Ê∫ê: ${itemSourceUrl}`;
                    }
                    li.style.cssText = 'padding: 5px 0;';
                } else {
                    // ÂÖºÂÆπÂÖ∂‰ªñ object format
                    const jsonStr = JSON.stringify(item);
                    li.textContent = jsonStr;
                    li.title = jsonStr;
                }
            } else {
                // Â¶ÇÊûúÊòØ string orÂÖ∂‰ªñÂü∫Êú¨ typeÔºådirectly display
                const displayValue = String(item);
                li.textContent = displayValue;
                li.title = displayValue;
            }
            
            listElement.appendChild(li);
        });
    }
}

function addLogEntry(message, type = 'info') {
    const logSection = document.getElementById('logSection');
    if (!logSection) return;
    
    // üöÄ performance optimizationÔºöÂè™ filter ÊúÄÈ¢ëÁπÅ  logÔºåkeepÈáçË¶Å information
    if (type === 'info' && (
        message.includes('success Ëé∑Âèñ content') ||
        message.includes('skipÈùû text content')
    )) {
        return; // Âè™skipËøô‰∫õÊúÄÈ¢ëÁπÅ  log
    }
    
    if (!logEntries) {
        logEntries = [];
    }
    
    // add Âà∞ÁºìÂÜ≤Âå∫
    if (!logBuffer) {
        logBuffer = [];
    }
    logBuffer.push({ message, type, time: new Date().toLocaleTimeString() });
    
    // batch refresh logÔºàÈôç‰ΩéÈ¢ëÁéáÔºâ
    if (!logFlushTimer) {
        logFlushTimer = setTimeout(() => {
            flushLogBuffer();
            logFlushTimer = null;
        }, LOG_FLUSH_INTERVAL);
    }
}

// batch refresh log ÁºìÂÜ≤Âå∫
function flushLogBuffer() {
    if (!logBuffer || logBuffer.length === 0) return;
    
    // Â∞ÜÁºìÂÜ≤Âå∫ content add Âà∞‰∏ª log array
    logEntries.push(...logBuffer);
    logBuffer = [];
    
    // limit log Êù°ÁõÆ count
    if (logEntries.length > maxLogEntries) {
        logEntries = logEntries.slice(-maxLogEntries);
    }
    
    // update display
    updateLogDisplay();
}

// üöÄ optimization   log display function - reduceDOMÊìç‰ΩúÈ¢ëÁéá
function updateLogDisplay() {
    const logSection = document.getElementById('logSection');
    if (!logSection || !logEntries) return;
    
    // üöÄ Èò≤Êäñ processÔºöÈÅøÂÖçÈ¢ëÁπÅ update DOM
    if (updateLogDisplay.pending) return;
    updateLogDisplay.pending = true;
    
    // Âè™ display ÊúÄËøë 20Êù° logÔºåËøõ‰∏ÄÊ≠•reduceDOMË¥üËΩΩ
    const recentLogs = logEntries.slice(-20);
    
    // check ÊòØÂê¶require updateÔºàÈÅøÂÖçdo notÂøÖË¶Å DOMÊìç‰ΩúÔºâ
    const currentLogCount = logSection.children.length;
    if (currentLogCount === recentLogs.length) {
        updateLogDisplay.pending = false;
        return; // Ê≤°ÊúâÊñ∞ logÔºåskip update
    }
    
    // üöÄ usesetTimeout delay updateÔºåÈÅøÂÖç blocking ÊªöÂä®
    setTimeout(() => {
        // use documentation ÁâáÊÆµ batch update
        const fragment = document.createDocumentFragment();
        recentLogs.forEach(log => {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${log.type}`;
            logEntry.textContent = `[${log.time}] ${log.message}`;
            fragment.appendChild(logEntry);
        });
        
        // userequestAnimationFrame optimization DOM update
        requestAnimationFrame(() => {
            logSection.innerHTML = '';
            logSection.appendChild(fragment);
            
            // üöÄ optimization ÊªöÂä®ÔºöÂè™inÂøÖË¶ÅÊó∂ÊªöÂä®
            if (!logSection.isUserScrolling) {
                logSection.scrollTop = logSection.scrollHeight;
            }
            
            updateLogDisplay.pending = false;
        });
    }, 100); // 100ms delayÔºåÈÅøÂÖçÈ¢ëÁπÅ update
}

// -------------------- tool function --------------------

// ËæÖÂä© functionÔºöËß£ÊûêÁõ∏ÂØπ path
function resolveRelativePath(relativePath, basePath) {
    try {
        if (!relativePath || !basePath) return null;
        
        // Á°Æ‰øùbasePath‰ª•/ÁªìÂ∞æ
        if (!basePath.endsWith('/')) {
            basePath += '/';
        }
        
        // useURLÊûÑÈÄ† function ËøõË°å standard Ëß£Êûê
        const resolved = new URL(relativePath, basePath);
        return resolved.href;
    } catch (error) {
        console.warn('Áõ∏ÂØπ path Ëß£Êûê failed:', error);
        return null;
    }
}

async function resolveUrl(url, baseUrl, sourceUrl = null) {
    try {
        if (!url) return null;
        
        console.log(`üîç [URLËß£Êûê] start Ëß£Êûê: "${url}", basicURL: "${baseUrl}", Ê∫êURL: "${sourceUrl}"`);
        
        // Â¶ÇÊûúalreadyÁªèÊòØÁªùÂØπURLÔºådirectlyËøîÂõû
        if (url.startsWith('http://') || url.startsWith('https://')) {
            console.log(`‚úÖ [URLËß£Êûê] alreadyÊòØÁªùÂØπURL: "${url}"`);
            return url;
        }
        
        if (url.startsWith('//')) {
            const result = new URL(baseUrl).protocol + url;
            console.log(`‚úÖ [URLËß£Êûê] protocol Áõ∏ÂØπURL: "${url}" -> "${result}"`);
            return result;
        }
        
        // üî• fixÔºö‰∏•Ê†ºÊåâÁÖßIndexedDB data Ëé∑Âèñ extract Êù•Ê∫ê path ËøõË°åÁõ∏ÂØπ path Ëß£Êûê
        if (sourceUrl && (url.startsWith('./') || url.startsWith('../') || !url.startsWith('/'))) {
            console.log(`üîç [URLËß£Êûê] Ê£ÄÊµãÂà∞Áõ∏ÂØπ pathÔºåÂ∞ùËØïuseIndexedDB data Ëß£Êûê`);
            
            try {
                // Ëé∑ÂèñallIndexedDB scan data
                let allScanData = [];
                
                // method 1: directlyfromIndexedDBManagerËé∑Âèñ current domain data
                try {
                    if (window.IndexedDBManager && window.IndexedDBManager.loadScanResults) {
                        const currentData = await window.IndexedDBManager.loadScanResults(baseUrl);
                        if (currentData && currentData.results) {
                            allScanData.push(currentData);
                            console.log(`‚úÖ [URLËß£Êûê] Ëé∑ÂèñÂà∞ current domain data`);
                        }
                    }
                } catch (error) {
                    console.warn('Ëé∑Âèñ current domain IndexedDB data failed:', error);
                }
                
                // method 2: Ëé∑Âèñall scan data ‰ΩútoÂ§áÈÄâ
                try {
                    if (window.IndexedDBManager && window.IndexedDBManager.getAllScanResults) {
                        const allData = await window.IndexedDBManager.getAllScanResults();
                        if (Array.isArray(allData)) {
                            allScanData = allScanData.concat(allData);
                            console.log(`‚úÖ [URLËß£Êûê] Ëé∑ÂèñÂà∞all scan dataÔºåÂÖ± ${allData.length} ‰∏™`);
                        }
                    }
                } catch (error) {
                    console.warn('Ëé∑ÂèñallIndexedDB data failed:', error);
                }
                
                if (allScanData.length > 0) {
                    // ÊûÑÂª∫sourceUrlÂà∞basePath  map
                    const sourceUrlToBasePath = new Map();
                    
                    console.log(`üîç [URLËß£Êûê] start analysis ${allScanData.length} ‰∏™ scan data Ê∫ê`);
                    
                    // ÈÅçÂéÜall scan dataÔºåÂª∫Á´ã map ÂÖ≥system
                    allScanData.forEach((scanData, dataIndex) => {
                        if (!scanData.results) return;
                        
                        // ÈÅçÂéÜall type   dataÔºåÂª∫Á´ã sourceUrl map
                        Object.values(scanData.results).forEach(items => {
                            if (Array.isArray(items)) {
                                items.forEach(item => {
                                    if (typeof item === 'object' && item.sourceUrl) {
                                        try {
                                            const sourceUrlObj = new URL(item.sourceUrl);
                                            // extract basic pathÔºàÂéªÊéâ file ÂêçÔºâ
                                            const basePath = sourceUrlObj.pathname.substring(0, sourceUrlObj.pathname.lastIndexOf('/') + 1);
                                            const correctBaseUrl = `${sourceUrlObj.protocol}//${sourceUrlObj.host}${basePath}`;
                                            sourceUrlToBasePath.set(item.sourceUrl, correctBaseUrl);
                                            
                                            console.log(`üìã [URLËß£Êûê] map Âª∫Á´ã: ${item.sourceUrl} ‚Üí ${correctBaseUrl}`);
                                        } catch (e) {
                                            console.warn('invalid  sourceUrl:', item.sourceUrl, e);
                                        }
                                    }
                                });
                            }
                        });
                        
                        // ‰πü add scan data Êú¨Ë∫´ sourceUrl‰ΩútoÂ§áÈÄâ
                        if (scanData.sourceUrl) {
                            try {
                                const sourceUrlObj = new URL(scanData.sourceUrl);
                                const basePath = sourceUrlObj.pathname.substring(0, sourceUrlObj.pathname.lastIndexOf('/') + 1);
                                const correctBaseUrl = `${sourceUrlObj.protocol}//${sourceUrlObj.host}${basePath}`;
                                sourceUrlToBasePath.set(scanData.sourceUrl, correctBaseUrl);
                                
                                console.log(`üìã [URLËß£Êûê] Â§áÈÄâ map: ${scanData.sourceUrl} ‚Üí ${correctBaseUrl}`);
                            } catch (e) {
                                console.warn('invalid  Â§áÈÄâsourceUrl:', scanData.sourceUrl, e);
                            }
                        }
                    });
                    
                    console.log(`üìä [URLËß£Êûê] map Âª∫Á´ã completeÔºåÂÖ± ${sourceUrlToBasePath.size} ‰∏™ map`);
                    
                    // üî• method 1ÔºöÁ≤æÁ°Æ match sourceUrl
                    if (sourceUrlToBasePath.has(sourceUrl)) {
                        const correctBasePath = sourceUrlToBasePath.get(sourceUrl);
                        const resolvedUrl = resolveRelativePath(url, correctBasePath);
                        if (resolvedUrl) {
                            console.log(`üéØ [URLËß£Êûê] Á≤æÁ°Æ match success: ${url} ‚Üí ${resolvedUrl} (Âü∫‰∫éÊ∫ê: ${sourceUrl})`);
                            return resolvedUrl;
                        }
                    }
                    
                    // üî• method 2Ôºödomain match
                    const targetDomain = baseUrl ? new URL(baseUrl).hostname : null;
                    if (targetDomain) {
                        for (const [storedSourceUrl, basePath] of sourceUrlToBasePath.entries()) {
                            try {
                                const sourceDomain = new URL(storedSourceUrl).hostname;
                                if (sourceDomain === targetDomain) {
                                    const testUrl = resolveRelativePath(url, basePath);
                                    if (testUrl) {
                                        console.log(`üéØ [URLËß£Êûê] domain match success: ${url} ‚Üí ${testUrl} (Âü∫‰∫éÊ∫ê: ${storedSourceUrl})`);
                                        return testUrl;
                                    }
                                }
                            } catch (e) {
                                // ÂøΩÁï• invalid URL
                            }
                        }
                    }
                    
                    // üî• method 3ÔºöÂ∞ùËØï‰ªª‰ΩïÂèØÁî® Ê∫êURL
                    for (const [storedSourceUrl, basePath] of sourceUrlToBasePath.entries()) {
                        const testUrl = resolveRelativePath(url, basePath);
                        if (testUrl) {
                            console.log(`üéØ [URLËß£Êûê] general match success: ${url} ‚Üí ${testUrl} (Âü∫‰∫éÊ∫ê: ${storedSourceUrl})`);
                            return testUrl;
                        }
                    }
                }
                
                console.log(`‚ö†Ô∏è [URLËß£Êûê] IndexedDBÊô∫ËÉΩËß£ÊûêÊú™ÊâæÂà∞ matchÔºåuse default method`);
                
            } catch (error) {
                console.warn('IndexedDBÊô∫ËÉΩ path Ëß£Êûê failedÔºåuse default method:', error);
            }
        }
        
        // üî• default methodÔºödirectlyÂü∫‰∫ébaseUrlËß£Êûê
        try {
            const resolvedUrl = new URL(url, baseUrl).href;
            console.log(`üìç [URLËß£Êûê] default Ëß£Êûê: ${url} ‚Üí ${resolvedUrl} (Âü∫‰∫é: ${baseUrl})`);
            return resolvedUrl;
        } catch (error) {
            console.warn('default URLËß£Êûê failed:', error);
            return null;
        }
        
    } catch (error) {
        console.warn('URLËß£ÊûêÂÆåÂÖ® failed:', error);
        return null;
    }
}

// check ÊòØÂê¶toÂêå‰∏Ä domain - supportÂ≠ê domain and all domain settings
async function isSameDomain(url, baseUrl) {
    try {
        const urlObj = new URL(url);
        const baseUrlObj = new URL(baseUrl);
        
        // Ëé∑Âèñ domain scan settings
        const domainSettings = await getDomainScanSettings();
        //console.log('üîç [deep scan] current domain settings:', domainSettings);
        //console.log('üîç [deep scan] check URL:', url, 'Âü∫ÂáÜURL:', baseUrl);
        
        // Â¶ÇÊûúÂÖÅËÆ∏ scan all domain
        if (domainSettings.allowAllDomains) {
            //console.log(`üåê [deep scan] ÂÖÅËÆ∏all domain: ${urlObj.hostname}`);
            addLogEntry(`üåê ÂÖÅËÆ∏all domain: ${urlObj.hostname}`, 'info');
            return true;
        }
        
        // Â¶ÇÊûúÂÖÅËÆ∏ scan Â≠ê domain
        if (domainSettings.allowSubdomains) {
            const baseHostname = baseUrlObj.hostname;
            const urlHostname = urlObj.hostname;
            
            // check ÊòØÂê¶toÂêå‰∏Ä domain orÂ≠ê domain
            const isSameOrSubdomain = urlHostname === baseHostname || 
                                    urlHostname.endsWith('.' + baseHostname) ||
                                    baseHostname.endsWith('.' + urlHostname);
            
            if (isSameOrSubdomain) {
                //console.log(`üîó [deep scan] ÂÖÅËÆ∏Â≠ê domain: ${urlHostname} (Âü∫‰∫é ${baseHostname})`);
                //addLogEntry(`üîó ÂÖÅËÆ∏Â≠ê domain: ${urlHostname}`, 'info');
                return true;
            }
        }
        
        // defaultÔºöÂè™ÂÖÅËÆ∏ÂÆåÂÖ®Áõ∏Âêå  domain
        const isSame = urlObj.hostname === baseUrlObj.hostname;
        if (isSame) {
            //console.log(`‚úÖ [deep scan] Âêå domain: ${urlObj.hostname}`);
        } else {
            //console.log(`‚ùå [deep scan] do notÂêå domain: ${urlObj.hostname} vs ${baseUrlObj.hostname}`);
        }
        return isSame;
        
    } catch (error) {
        console.error('[deep scan] domain check failed:', error);
        return false;
    }
}

// Ëé∑Âèñ domain scan settings
async function getDomainScanSettings() {
    try {
        // Â¶ÇÊûúSettingsManagerÂèØÁî®ÔºåuseÂÆÉËé∑Âèñ settings
        if (typeof window.SettingsManager !== 'undefined' && window.SettingsManager.getDomainScanSettings) {
            return await window.SettingsManager.getDomainScanSettings();
        }
        
        // Â§áÁî®ÊñπÊ°àÔºödirectlyfromchrome.storageËé∑Âèñ
        const result = await chrome.storage.local.get(['domainScanSettings']);
        const domainSettings = result.domainScanSettings || {
            allowSubdomains: false,
            allowAllDomains: false
        };
        //console.log('üîç [deep scan] fromstorageËé∑Âèñ  domain settings:', domainSettings);
        return domainSettings;
    } catch (error) {
        console.error('[deep scan] Ëé∑Âèñ domain scan settings failed:', error);
        // default settingsÔºöÂè™ÂÖÅËÆ∏Âêå domain
        return {
            allowSubdomains: false,
            allowAllDomains: false
        };
    }
}

function isValidPageUrl(url) {
    if (!url || url.startsWith('#') || url.startsWith('javascript:') || url.startsWith('mailto:')) {
        return false;
    }
    
    const resourceExtensions = /\.(css|js|png|jpg|jpeg|gif|svg|ico|woff|ttf|eot|woff2|map|pdf|zip)$/i;
    return !resourceExtensions.test(url.toLowerCase());
}

// -------------------- export feature --------------------
function exportResults() {
    const modal = document.getElementById('exportModal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

function toggleAllCategories() {
    const categories = document.querySelectorAll('.result-category');
    const hasVisible = Array.from(categories).some(cat => cat.style.display !== 'none');
    
    categories.forEach(category => {
        category.style.display = hasVisible ? 'none' : 'block';
    });
}

// -------------------- event listener --------------------
document.addEventListener('DOMContentLoaded', initializePage);

// export popup event
document.addEventListener('click', (e) => {
    if (e.target.id === 'closeExportModal' || e.target.id === 'exportModal') {
        document.getElementById('exportModal').style.display = 'none';
    }
    
    if (e.target.id === 'exportJSON') {
        exportAsJSON();
        document.getElementById('exportModal').style.display = 'none';
    }
    
    if (e.target.id === 'exportXLS') {
        exportAsExcel();
        document.getElementById('exportModal').style.display = 'none';
    }
});

async function exportAsJSON() {
    try {
        const filename = await generateFileName('json');
        const dataStr = JSON.stringify(scanResults, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = filename;
        link.click();
        
        addLogEntry(`‚úÖ JSON export success: ${filename}`, 'success');
    } catch (error) {
        addLogEntry(`‚ùå JSON export failed: ${error.message}`, 'error');
    }
}

async function exportAsExcel() {
    try {
        const filename = await generateFileName('xlsx');
        
        // check ÊòØÂê¶Êúâ data can export
        const hasData = Object.keys(scanResults).some(key => 
            scanResults[key] && Array.isArray(scanResults[key]) && scanResults[key].length > 0
        );
        
        if (!hasData) {
            addLogEntry(`‚ö†Ô∏è Ê≤°Êúâ data can export`, 'warning');
            return;
        }
        
        // ÁîüÊàêExcel XML format content
        let xlsContent = `<?xml version="1.0"?>
<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet"
 xmlns:o="urn:schemas-microsoft-com:office:office"
 xmlns:x="urn:schemas-microsoft-com:office:excel"
 xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"
 xmlns:html="http://www.w3.org/TR/REC-html40">
 <DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">
  <Author>phantomÂ∑•ÂÖ∑-deep scan</Author>
  <Created>${new Date().toISOString()}</Created>
 </DocumentProperties>
 <Styles>
  <Style ss:ID="Header">
   <Font ss:Bold="1"/>
   <Interior ss:Color="#D4EDF9" ss:Pattern="Solid"/>
   <Borders>
    <Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1"/>
    <Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1"/>
    <Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1"/>
    <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1"/>
   </Borders>
  </Style>
  <Style ss:ID="Data">
   <Borders>
    <Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1"/>
    <Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1"/>
    <Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1"/>
    <Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1"/>
   </Borders>
  </Style>
 </Styles>`;

        // toÊØè‰∏™ÂàÜÁ±ªÂàõÂª∫Â∑•‰ΩúË°®
        const categories = Object.keys(scanResults);
        let dataExported = false;

        categories.forEach(category => {
            const items = scanResults[category];
            if (Array.isArray(items) && items.length > 0) {
                dataExported = true;
                const sheetName = sanitizeSheetName(category);
                
                xlsContent += `
 <Worksheet ss:Name="${escapeXml(sheetName)}">
  <Table>
   <Column ss:Width="50"/>
   <Column ss:Width="400"/>
   <Column ss:Width="120"/>
   <Row>
    <Cell ss:StyleID="Header"><Data ss:Type="String">Â∫èÂè∑</Data></Cell>
    <Cell ss:StyleID="Header"><Data ss:Type="String">ÂÜÖÂÆπ</Data></Cell>
    <Cell ss:StyleID="Header"><Data ss:Type="String">ÂàÜÁ±ª</Data></Cell>
   </Row>`;

                items.forEach((item, index) => {
                    xlsContent += `
   <Row>
    <Cell ss:StyleID="Data"><Data ss:Type="Number">${index + 1}</Data></Cell>
    <Cell ss:StyleID="Data"><Data ss:Type="String">${escapeXml(String(item))}</Data></Cell>
    <Cell ss:StyleID="Data"><Data ss:Type="String">${escapeXml(category)}</Data></Cell>
   </Row>`;
                });

                xlsContent += `
  </Table>
 </Worksheet>`;
            }
        });

        // Â¶ÇÊûúÊ≤°Êúâ dataÔºåÂàõÂª∫‰∏Ä‰∏™ empty  Â∑•‰ΩúË°®
        if (!dataExported) {
            xlsContent += `
 <Worksheet ss:Name="Êó† data">
  <Table>
   <Column ss:Width="200"/>
   <Row>
    <Cell ss:StyleID="Header"><Data ss:Type="String">ÊèêÁ§∫</Data></Cell>
   </Row>
   <Row>
    <Cell ss:StyleID="Data"><Data ss:Type="String">Ê≤°ÊúâÊâæÂà∞‰ªª‰Ωïdata</Data></Cell>
   </Row>
  </Table>
 </Worksheet>`;
        }

        xlsContent += `
</Workbook>`;

        // ÂàõÂª∫Âπ∂ download file
        const blob = new Blob([xlsContent], { 
            type: 'application/vnd.ms-excel;charset=utf-8' 
        });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `${filename}.xls`;
        a.click();
        
        URL.revokeObjectURL(url);
        
        addLogEntry(`‚úÖ Excel file export success: ${filename}.xls`, 'success');
        
    } catch (error) {
        addLogEntry(`‚ùå Excel export failed: ${error.message}`, 'error');
        console.error('Excel export error:', error);
    }
}

// cleanup Â∑•‰ΩúË°®ÂêçÁß∞ÔºàExcelÂ∑•‰ΩúË°®ÂêçÁß∞ÊúâÁâπÊÆäÂ≠óÁ¨¶ limitÔºâ
function sanitizeSheetName(name) {
    // remove or replace Exceldo notÂÖÅËÆ∏ Â≠óÁ¨¶
    let sanitized = name.replace(/[\\\/\?\*\[\]:]/g, '_');
    // limit lengthÔºàExcelÂ∑•‰ΩúË°®ÂêçÁß∞ maximum 31 itemsÂ≠óÁ¨¶Ôºâ
    if (sanitized.length > 31) {
        sanitized = sanitized.substring(0, 28) + '...';
    }
    return sanitized || 'Êú™ÂëΩÂêç';
}

// XMLËΩ¨‰πâ function
function escapeXml(text) {
    return String(text)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
}

// ÁîüÊàê file ÂêçÔºödomain __ÈöèÊú∫Êï∞
async function generateFileName(extension = 'json') {
    let domain = 'deep-scan';
    
    try {
        // ‰ºòÂÖàfrom scan configuration inËé∑ÂèñÁõÆÊ†á domain
        if (scanConfig && scanConfig.baseUrl) {
            const url = new URL(scanConfig.baseUrl);
            domain = url.hostname;
            //console.log('from scan configuration Ëé∑ÂèñÂà∞ domain:', domain);
        } else {
            // Â§áÈÄâÊñπÊ°àÔºöfrom current window URL parameter in extract ÁõÆÊ†á domain
            if (window.location && window.location.href) {
                const urlParams = new URLSearchParams(window.location.search);
                const targetUrl = urlParams.get('url');
                if (targetUrl) {
                    const url = new URL(targetUrl);
                    domain = url.hostname;
                    //console.log('fromURL parameter Ëé∑ÂèñÂà∞ domain:', domain);
                }
            }
        }
    } catch (e) {
        //console.log('Ëé∑Âèñ domain failedÔºåuse default ÂêçÁß∞:', e);
        // useÊó∂Èó¥Êà≥‰ΩútoÊ†áËØÜ
        domain = `deep-scan_${Date.now()}`;
    }
    
    // cleanup domainÔºåremove ÁâπÊÆäÂ≠óÁ¨¶
    domain = domain.replace(/[^a-zA-Z0-9.-]/g, '_');
    
    // ÁîüÊàêÈöèÊú∫Êï∞Ôºà6-digitÔºâ
    const randomNum = Math.floor(100000 + Math.random() * 900000);
    
    return `${domain}__${randomNum}`;
}

//console.log('‚úÖ [DEBUG] deep scan window scriptÔºàunified regex versionÔºâload complete');